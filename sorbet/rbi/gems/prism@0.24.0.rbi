# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `prism` gem.
# Please instead update this file by running `bin/tapioca gem prism`.

# =begin
# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/rbi/prism.rbi.erb
# if you are looking to modify the template
# =end

# Represents the use of the `alias` keyword to alias a global variable.
#
#     alias $foo $bar
#     ^^^^^^^^^^^^^^^
class Prism::AliasGlobalVariableNode < Prism::Node
  sig do
    params(
      new_name: Prism::Node,
      old_name: Prism::Node,
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(new_name, old_name, keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::AliasGlobalVariableNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(Prism::Node) }
  def new_name; end

  sig { returns(Prism::Node) }
  def old_name; end
end

# Represents the use of the `alias` keyword to alias a method.
#
#     alias foo bar
#     ^^^^^^^^^^^^^
class Prism::AliasMethodNode < Prism::Node
  sig do
    params(
      new_name: Prism::Node,
      old_name: Prism::Node,
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(new_name, old_name, keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::AliasMethodNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(Prism::Node) }
  def new_name; end

  sig { returns(Prism::Node) }
  def old_name; end
end

# Represents an alternation pattern in pattern matching.
#
#     foo => bar | baz
#            ^^^^^^^^^
class Prism::AlternationPatternNode < Prism::Node
  sig { params(left: Prism::Node, right: Prism::Node, operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(left, right, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::AlternationPatternNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Prism::Node) }
  def left; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def right; end
end

# Represents the use of the `&&` operator or the `and` keyword.
#
#     left and right
#     ^^^^^^^^^^^^^^
class Prism::AndNode < Prism::Node
  sig { params(left: Prism::Node, right: Prism::Node, operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(left, right, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::AndNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Prism::Node) }
  def left; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def right; end
end

# Represents a set of arguments to a method or a keyword.
#
#     return foo, bar, baz
#            ^^^^^^^^^^^^^
class Prism::ArgumentsNode < Prism::Node
  sig { params(flags: Integer, arguments: T::Array[Prism::Node], location: Prism::Location).void }
  def initialize(flags, arguments, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[Prism::Node]) }
  def arguments; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T::Boolean) }
  def contains_keyword_splat?; end

  sig { params(params: T.untyped).returns(Prism::ArgumentsNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Flags for arguments nodes.
module Prism::ArgumentsNodeFlags
  # if arguments contain keyword splat
  CONTAINS_KEYWORD_SPLAT = T.let(1 << 0, Integer)
end

# Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.
#
#     [1, 2, 3]
#     ^^^^^^^^^
class Prism::ArrayNode < Prism::Node
  sig do
    params(
      flags: Integer,
      elements: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(flags, elements, opening_loc, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { returns(T::Boolean) }
  def contains_splat?; end

  sig { params(params: T.untyped).returns(Prism::ArrayNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end
end

# Flags for array nodes.
module Prism::ArrayNodeFlags
  # if array contains splat nodes
  CONTAINS_SPLAT = T.let(1 << 0, Integer)
end

# Represents an array pattern in pattern matching.
#
#     foo in 1, 2
#     ^^^^^^^^^^^
#
#     foo in [1, 2]
#     ^^^^^^^^^^^^^
#
#     foo in *1
#     ^^^^^^^^^
#
#     foo in Bar[]
#     ^^^^^^^^^^^^
#
#     foo in Bar[1, 2, 3]
#     ^^^^^^^^^^^^^^^^^^^
class Prism::ArrayPatternNode < Prism::Node
  sig do
    params(
      constant: T.nilable(Prism::Node),
      requireds: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(constant, requireds, rest, posts, opening_loc, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def constant; end

  sig { params(params: T.untyped).returns(Prism::ArrayPatternNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T::Array[Prism::Node]) }
  def posts; end

  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  sig { returns(T.nilable(Prism::Node)) }
  def rest; end
end

# Represents a hash key/value pair.
#
#     { a => b }
#       ^^^^^^
class Prism::AssocNode < Prism::Node
  sig do
    params(
      key: Prism::Node,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(key, value, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::AssocNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Prism::Node) }
  def key; end

  sig { returns(T.nilable(String)) }
  def operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents a splat in a hash literal.
#
#     { **foo }
#       ^^^^^
class Prism::AssocSplatNode < Prism::Node
  sig { params(value: T.nilable(Prism::Node), operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(value, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::AssocSplatNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def value; end
end

# Represents reading a reference to a field in the previous match.
#
#     $'
#     ^^
class Prism::BackReferenceReadNode < Prism::Node
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::BackReferenceReadNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

class Prism::BasicVisitor
  sig { params(node: T.nilable(Prism::Node)).void }
  def visit(node); end

  sig { params(nodes: T::Array[T.nilable(Prism::Node)]).void }
  def visit_all(nodes); end

  sig { params(node: Prism::Node).void }
  def visit_child_nodes(node); end
end

# Represents a begin statement.
#
#     begin
#       foo
#     end
#     ^^^^^
class Prism::BeginNode < Prism::Node
  sig do
    params(
      begin_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      rescue_clause: T.nilable(Prism::RescueNode),
      else_clause: T.nilable(Prism::ElseNode),
      ensure_clause: T.nilable(Prism::EnsureNode),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(String)) }
  def begin_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def begin_keyword_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::BeginNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  sig { returns(T.nilable(String)) }
  def end_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { returns(T.nilable(Prism::EnsureNode)) }
  def ensure_clause; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::RescueNode)) }
  def rescue_clause; end

  def set_newline_flag(newline_marked); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

# Represents block method arguments.
#
#     bar(&args)
#     ^^^^^^^^^^
class Prism::BlockArgumentNode < Prism::Node
  sig { params(expression: T.nilable(Prism::Node), operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(expression, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::BlockArgumentNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(Prism::Node)) }
  def expression; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end
end

# Represents a block local variable.
#
#     a { |; b| }
#            ^
class Prism::BlockLocalVariableNode < Prism::Node
  sig { params(flags: Integer, name: Symbol, location: Prism::Location).void }
  def initialize(flags, name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::BlockLocalVariableNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end
end

# Represents a block of ruby code.
#
#     [1, 2, 3].each { |i| puts x }
#                    ^^^^^^^^^^^^^^
class Prism::BlockNode < Prism::Node
  sig do
    params(
      locals: T::Array[Symbol],
      parameters: T.nilable(Prism::Node),
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(locals, parameters, body, opening_loc, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::BlockNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def parameters; end
end

# Represents a block parameter to a method, block, or lambda definition.
#
#     def a(&b)
#           ^^
#     end
class Prism::BlockParameterNode < Prism::Node
  sig do
    params(
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(flags, name, name_loc, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::BlockParameterNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Symbol)) }
  def name; end

  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end
end

# Represents a block's parameters declaration.
#
#     -> (a, b = 1; local) { }
#        ^^^^^^^^^^^^^^^^^
#
#     foo do |a, b = 1; local|
#            ^^^^^^^^^^^^^^^^^
#     end
class Prism::BlockParametersNode < Prism::Node
  sig do
    params(
      parameters: T.nilable(Prism::ParametersNode),
      locals: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(parameters, locals, opening_loc, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::BlockParametersNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Prism::Node]) }
  def locals; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T.nilable(Prism::ParametersNode)) }
  def parameters; end
end

# Represents the use of the `break` keyword.
#
#     break foo
#     ^^^^^^^^^
class Prism::BreakNode < Prism::Node
  sig do
    params(
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(arguments, keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::BreakNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end
end

# Represents the use of the `&&=` operator on a call.
#
#     foo.bar &&= value
#     ^^^^^^^^^^^^^^^^^
class Prism::CallAndWriteNode < Prism::Node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::CallAndWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def message; end

  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Symbol) }
  def read_name; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  sig { returns(Symbol) }
  def write_name; end
end

# Represents a method call, in all of the various forms that can take.
#
#     foo
#     ^^^
#
#     foo()
#     ^^^^^
#
#     +foo
#     ^^^^
#
#     foo + bar
#     ^^^^^^^^^
#
#     foo.bar
#     ^^^^^^^
#
#     foo&.bar
#     ^^^^^^^^
class Prism::CallNode < Prism::Node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      name: Symbol,
      message_loc: T.nilable(Prism::Location),
      opening_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: T.nilable(Prism::Location),
      block: T.nilable(Prism::Node),
      location: Prism::Location
    ).void
  end
  def initialize(flags, receiver, call_operator_loc, name, message_loc, opening_loc, arguments, closing_loc, block, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::CallNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def message; end

  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  sig { returns(T::Boolean) }
  def variable_call?; end
end

# Flags for call nodes.
module Prism::CallNodeFlags
  # a call that is an attribute write, so the value being written should be returned
  ATTRIBUTE_WRITE = T.let(1 << 2, Integer)

  # a call that ignores method visibility
  IGNORE_VISIBILITY = T.let(1 << 3, Integer)

  # &. operator
  SAFE_NAVIGATION = T.let(1 << 0, Integer)

  # a call that could have been a local variable
  VARIABLE_CALL = T.let(1 << 1, Integer)
end

# Represents the use of an assignment operator on a call.
#
#     foo.bar += baz
#     ^^^^^^^^^^^^^^
class Prism::CallOperatorWriteNode < Prism::Node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::CallOperatorWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def message; end

  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  sig { returns(Symbol) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Symbol) }
  def read_name; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  sig { returns(Symbol) }
  def write_name; end
end

# Represents the use of the `||=` operator on a call.
#
#     foo.bar ||= value
#     ^^^^^^^^^^^^^^^^^
class Prism::CallOrWriteNode < Prism::Node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::CallOrWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def message; end

  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Symbol) }
  def read_name; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end

  sig { returns(Symbol) }
  def write_name; end
end

# Represents assigning to a method call.
#
#     foo.bar, = 1
#     ^^^^^^^
#
#     begin
#     rescue => foo.bar
#               ^^^^^^^
#     end
#
#     for foo.bar in baz do end
#         ^^^^^^^
class Prism::CallTargetNode < Prism::Node
  sig do
    params(
      flags: Integer,
      receiver: Prism::Node,
      call_operator_loc: Prism::Location,
      name: Symbol,
      message_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(flags, receiver, call_operator_loc, name, message_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(String) }
  def call_operator; end

  sig { returns(Prism::Location) }
  def call_operator_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::CallTargetNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def message; end

  sig { returns(Prism::Location) }
  def message_loc; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Node) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  sig { returns(T::Boolean) }
  def variable_call?; end
end

# Represents assigning to a local variable in pattern matching.
#
#     foo => [bar => baz]
#            ^^^^^^^^^^^^
class Prism::CapturePatternNode < Prism::Node
  sig do
    params(
      value: Prism::Node,
      target: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(value, target, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::CapturePatternNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def target; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of a case statement for pattern matching.
#
#     case true
#     in false
#     end
#     ^^^^^^^^^
class Prism::CaseMatchNode < Prism::Node
  sig do
    params(
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::Node],
      consequent: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(String) }
  def case_keyword; end

  sig { returns(Prism::Location) }
  def case_keyword_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  sig { returns(T.nilable(Prism::ElseNode)) }
  def consequent; end

  sig { params(params: T.untyped).returns(Prism::CaseMatchNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::Node)) }
  def predicate; end
end

# Represents the use of a case statement.
#
#     case true
#     when false
#     end
#     ^^^^^^^^^^
class Prism::CaseNode < Prism::Node
  sig do
    params(
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::Node],
      consequent: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(String) }
  def case_keyword; end

  sig { returns(Prism::Location) }
  def case_keyword_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  sig { returns(T.nilable(Prism::ElseNode)) }
  def consequent; end

  sig { params(params: T.untyped).returns(Prism::CaseNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::Node)) }
  def predicate; end
end

# Represents a class declaration involving the `class` keyword.
#
#     class Foo end
#     ^^^^^^^^^^^^^
class Prism::ClassNode < Prism::Node
  sig do
    params(
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      constant_path: Prism::Node,
      inheritance_operator_loc: T.nilable(Prism::Location),
      superclass: T.nilable(Prism::Node),
      body: T.nilable(Prism::Node),
      end_keyword_loc: Prism::Location,
      name: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def class_keyword; end

  sig { returns(Prism::Location) }
  def class_keyword_loc; end

  sig { returns(Prism::Node) }
  def constant_path; end

  sig { params(params: T.untyped).returns(Prism::ClassNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { returns(T.nilable(String)) }
  def inheritance_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def inheritance_operator_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(T.nilable(Prism::Node)) }
  def superclass; end
end

# Represents the use of the `&&=` operator for assignment to a class variable.
#
#     @@target &&= value
#     ^^^^^^^^^^^^^^^^^^
class Prism::ClassVariableAndWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ClassVariableAndWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents assigning to a class variable using an operator that isn't `=`.
#
#     @@target += value
#     ^^^^^^^^^^^^^^^^^
class Prism::ClassVariableOperatorWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ClassVariableOperatorWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(Symbol) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of the `||=` operator for assignment to a class variable.
#
#     @@target ||= value
#     ^^^^^^^^^^^^^^^^^^
class Prism::ClassVariableOrWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ClassVariableOrWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents referencing a class variable.
#
#     @@foo
#     ^^^^^
class Prism::ClassVariableReadNode < Prism::Node
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ClassVariableReadNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

# Represents writing to a class variable in a context that doesn't have an explicit value.
#
#     @@foo, @@bar = baz
#     ^^^^^  ^^^^^
class Prism::ClassVariableTargetNode < Prism::Node
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ClassVariableTargetNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

# Represents writing to a class variable.
#
#     @@foo = 1
#     ^^^^^^^^^
class Prism::ClassVariableWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, value, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ClassVariableWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(T.nilable(String)) }
  def operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

class Prism::Comment
  sig { returns(Prism::Location) }
  def location; end

  sig { returns(T::Boolean) }
  def trailing?; end
end

# Represents the use of the `&&=` operator for assignment to a constant.
#
#     Target &&= value
#     ^^^^^^^^^^^^^^^^
class Prism::ConstantAndWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantAndWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents assigning to a constant using an operator that isn't `=`.
#
#     Target += value
#     ^^^^^^^^^^^^^^^
class Prism::ConstantOperatorWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantOperatorWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(Symbol) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of the `||=` operator for assignment to a constant.
#
#     Target ||= value
#     ^^^^^^^^^^^^^^^^
class Prism::ConstantOrWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantOrWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of the `&&=` operator for assignment to a constant path.
#
#     Parent::Child &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
class Prism::ConstantPathAndWriteNode < Prism::Node
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(target, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantPathAndWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::ConstantPathNode) }
  def target; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents accessing a constant through a path of `::` operators.
#
#     Foo::Bar
#     ^^^^^^^^
class Prism::ConstantPathNode < Prism::Node
  sig do
    params(
      parent: T.nilable(Prism::Node),
      child: Prism::Node,
      delimiter_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(parent, child, delimiter_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(Prism::Node) }
  def child; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantPathNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def delimiter; end

  sig { returns(Prism::Location) }
  def delimiter_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::Node)) }
  def parent; end
end

# Represents assigning to a constant path using an operator that isn't `=`.
#
#     Parent::Child += value
#     ^^^^^^^^^^^^^^^^^^^^^^
class Prism::ConstantPathOperatorWriteNode < Prism::Node
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(target, operator_loc, value, operator, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantPathOperatorWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::ConstantPathNode) }
  def target; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of the `||=` operator for assignment to a constant path.
#
#     Parent::Child ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
class Prism::ConstantPathOrWriteNode < Prism::Node
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(target, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantPathOrWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::ConstantPathNode) }
  def target; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents writing to a constant path in a context that doesn't have an explicit value.
#
#     Foo::Foo, Bar::Bar = baz
#     ^^^^^^^^  ^^^^^^^^
class Prism::ConstantPathTargetNode < Prism::Node
  sig do
    params(
      parent: T.nilable(Prism::Node),
      child: Prism::Node,
      delimiter_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(parent, child, delimiter_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(Prism::Node) }
  def child; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantPathTargetNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def delimiter; end

  sig { returns(Prism::Location) }
  def delimiter_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::Node)) }
  def parent; end
end

# Represents writing to a constant path.
#
#     ::Foo = 1
#     ^^^^^^^^^
#
#     Foo::Bar = 1
#     ^^^^^^^^^^^^
#
#     ::Foo::Bar = 1
#     ^^^^^^^^^^^^^^
class Prism::ConstantPathWriteNode < Prism::Node
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(target, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantPathWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::ConstantPathNode) }
  def target; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents referencing a constant.
#
#     Foo
#     ^^^
class Prism::ConstantReadNode < Prism::Node
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantReadNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

# Represents writing to a constant in a context that doesn't have an explicit value.
#
#     Foo, Bar = baz
#     ^^^  ^^^
class Prism::ConstantTargetNode < Prism::Node
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantTargetNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

# Represents writing to a constant.
#
#     Foo = 1
#     ^^^^^^^
class Prism::ConstantWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, value, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ConstantWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

class Prism::DATAComment < Prism::Comment; end

module Prism::DSL
  # Create a new AliasGlobalVariableNode node
  sig do
    params(
      new_name: Prism::Node,
      old_name: Prism::Node,
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::AliasGlobalVariableNode)
  end
  def AliasGlobalVariableNode(new_name, old_name, keyword_loc, location); end

  # Create a new AliasMethodNode node
  sig do
    params(
      new_name: Prism::Node,
      old_name: Prism::Node,
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::AliasMethodNode)
  end
  def AliasMethodNode(new_name, old_name, keyword_loc, location); end

  # Create a new AlternationPatternNode node
  sig do
    params(
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::AlternationPatternNode)
  end
  def AlternationPatternNode(left, right, operator_loc, location); end

  # Create a new AndNode node
  sig do
    params(
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::AndNode)
  end
  def AndNode(left, right, operator_loc, location); end

  # Create a new ArgumentsNode node
  sig do
    params(
      flags: Integer,
      arguments: T::Array[Prism::Node],
      location: Prism::Location
    ).returns(Prism::ArgumentsNode)
  end
  def ArgumentsNode(flags, arguments, location); end

  # Create a new ArrayNode node
  sig do
    params(
      flags: Integer,
      elements: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::ArrayNode)
  end
  def ArrayNode(flags, elements, opening_loc, closing_loc, location); end

  # Create a new ArrayPatternNode node
  sig do
    params(
      constant: T.nilable(Prism::Node),
      requireds: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::ArrayPatternNode)
  end
  def ArrayPatternNode(constant, requireds, rest, posts, opening_loc, closing_loc, location); end

  # Create a new AssocNode node
  sig do
    params(
      key: Prism::Node,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::AssocNode)
  end
  def AssocNode(key, value, operator_loc, location); end

  # Create a new AssocSplatNode node
  sig do
    params(
      value: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::AssocSplatNode)
  end
  def AssocSplatNode(value, operator_loc, location); end

  # Create a new BackReferenceReadNode node
  sig { params(name: Symbol, location: Prism::Location).returns(Prism::BackReferenceReadNode) }
  def BackReferenceReadNode(name, location); end

  # Create a new BeginNode node
  sig do
    params(
      begin_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      rescue_clause: T.nilable(Prism::RescueNode),
      else_clause: T.nilable(Prism::ElseNode),
      ensure_clause: T.nilable(Prism::EnsureNode),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::BeginNode)
  end
  def BeginNode(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end

  # Create a new BlockArgumentNode node
  sig do
    params(
      expression: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::BlockArgumentNode)
  end
  def BlockArgumentNode(expression, operator_loc, location); end

  # Create a new BlockLocalVariableNode node
  sig { params(flags: Integer, name: Symbol, location: Prism::Location).returns(Prism::BlockLocalVariableNode) }
  def BlockLocalVariableNode(flags, name, location); end

  # Create a new BlockNode node
  sig do
    params(
      locals: T::Array[Symbol],
      parameters: T.nilable(Prism::Node),
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::BlockNode)
  end
  def BlockNode(locals, parameters, body, opening_loc, closing_loc, location); end

  # Create a new BlockParameterNode node
  sig do
    params(
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::BlockParameterNode)
  end
  def BlockParameterNode(flags, name, name_loc, operator_loc, location); end

  # Create a new BlockParametersNode node
  sig do
    params(
      parameters: T.nilable(Prism::ParametersNode),
      locals: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::BlockParametersNode)
  end
  def BlockParametersNode(parameters, locals, opening_loc, closing_loc, location); end

  # Create a new BreakNode node
  sig do
    params(
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::BreakNode)
  end
  def BreakNode(arguments, keyword_loc, location); end

  # Create a new CallAndWriteNode node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::CallAndWriteNode)
  end
  def CallAndWriteNode(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location); end

  # Create a new CallNode node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      name: Symbol,
      message_loc: T.nilable(Prism::Location),
      opening_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: T.nilable(Prism::Location),
      block: T.nilable(Prism::Node),
      location: Prism::Location
    ).returns(Prism::CallNode)
  end
  def CallNode(flags, receiver, call_operator_loc, name, message_loc, opening_loc, arguments, closing_loc, block, location); end

  # Create a new CallOperatorWriteNode node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::CallOperatorWriteNode)
  end
  def CallOperatorWriteNode(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator, operator_loc, value, location); end

  # Create a new CallOrWriteNode node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::CallOrWriteNode)
  end
  def CallOrWriteNode(flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value, location); end

  # Create a new CallTargetNode node
  sig do
    params(
      flags: Integer,
      receiver: Prism::Node,
      call_operator_loc: Prism::Location,
      name: Symbol,
      message_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::CallTargetNode)
  end
  def CallTargetNode(flags, receiver, call_operator_loc, name, message_loc, location); end

  # Create a new CapturePatternNode node
  sig do
    params(
      value: Prism::Node,
      target: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::CapturePatternNode)
  end
  def CapturePatternNode(value, target, operator_loc, location); end

  # Create a new CaseMatchNode node
  sig do
    params(
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::Node],
      consequent: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::CaseMatchNode)
  end
  def CaseMatchNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  # Create a new CaseNode node
  sig do
    params(
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::Node],
      consequent: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::CaseNode)
  end
  def CaseNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  # Create a new ClassNode node
  sig do
    params(
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      constant_path: Prism::Node,
      inheritance_operator_loc: T.nilable(Prism::Location),
      superclass: T.nilable(Prism::Node),
      body: T.nilable(Prism::Node),
      end_keyword_loc: Prism::Location,
      name: Symbol,
      location: Prism::Location
    ).returns(Prism::ClassNode)
  end
  def ClassNode(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name, location); end

  # Create a new ClassVariableAndWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::ClassVariableAndWriteNode)
  end
  def ClassVariableAndWriteNode(name, name_loc, operator_loc, value, location); end

  # Create a new ClassVariableOperatorWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).returns(Prism::ClassVariableOperatorWriteNode)
  end
  def ClassVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location); end

  # Create a new ClassVariableOrWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::ClassVariableOrWriteNode)
  end
  def ClassVariableOrWriteNode(name, name_loc, operator_loc, value, location); end

  # Create a new ClassVariableReadNode node
  sig { params(name: Symbol, location: Prism::Location).returns(Prism::ClassVariableReadNode) }
  def ClassVariableReadNode(name, location); end

  # Create a new ClassVariableTargetNode node
  sig { params(name: Symbol, location: Prism::Location).returns(Prism::ClassVariableTargetNode) }
  def ClassVariableTargetNode(name, location); end

  # Create a new ClassVariableWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::ClassVariableWriteNode)
  end
  def ClassVariableWriteNode(name, name_loc, value, operator_loc, location); end

  # Create a new ConstantAndWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::ConstantAndWriteNode)
  end
  def ConstantAndWriteNode(name, name_loc, operator_loc, value, location); end

  # Create a new ConstantOperatorWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).returns(Prism::ConstantOperatorWriteNode)
  end
  def ConstantOperatorWriteNode(name, name_loc, operator_loc, value, operator, location); end

  # Create a new ConstantOrWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::ConstantOrWriteNode)
  end
  def ConstantOrWriteNode(name, name_loc, operator_loc, value, location); end

  # Create a new ConstantPathAndWriteNode node
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::ConstantPathAndWriteNode)
  end
  def ConstantPathAndWriteNode(target, operator_loc, value, location); end

  # Create a new ConstantPathNode node
  sig do
    params(
      parent: T.nilable(Prism::Node),
      child: Prism::Node,
      delimiter_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::ConstantPathNode)
  end
  def ConstantPathNode(parent, child, delimiter_loc, location); end

  # Create a new ConstantPathOperatorWriteNode node
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).returns(Prism::ConstantPathOperatorWriteNode)
  end
  def ConstantPathOperatorWriteNode(target, operator_loc, value, operator, location); end

  # Create a new ConstantPathOrWriteNode node
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::ConstantPathOrWriteNode)
  end
  def ConstantPathOrWriteNode(target, operator_loc, value, location); end

  # Create a new ConstantPathTargetNode node
  sig do
    params(
      parent: T.nilable(Prism::Node),
      child: Prism::Node,
      delimiter_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::ConstantPathTargetNode)
  end
  def ConstantPathTargetNode(parent, child, delimiter_loc, location); end

  # Create a new ConstantPathWriteNode node
  sig do
    params(
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::ConstantPathWriteNode)
  end
  def ConstantPathWriteNode(target, operator_loc, value, location); end

  # Create a new ConstantReadNode node
  sig { params(name: Symbol, location: Prism::Location).returns(Prism::ConstantReadNode) }
  def ConstantReadNode(name, location); end

  # Create a new ConstantTargetNode node
  sig { params(name: Symbol, location: Prism::Location).returns(Prism::ConstantTargetNode) }
  def ConstantTargetNode(name, location); end

  # Create a new ConstantWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::ConstantWriteNode)
  end
  def ConstantWriteNode(name, name_loc, value, operator_loc, location); end

  # Create a new DefNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      receiver: T.nilable(Prism::Node),
      parameters: T.nilable(Prism::ParametersNode),
      body: T.nilable(Prism::Node),
      locals: T::Array[Symbol],
      def_keyword_loc: Prism::Location,
      operator_loc: T.nilable(Prism::Location),
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::DefNode)
  end
  def DefNode(name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end

  # Create a new DefinedNode node
  sig do
    params(
      lparen_loc: T.nilable(Prism::Location),
      value: Prism::Node,
      rparen_loc: T.nilable(Prism::Location),
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::DefinedNode)
  end
  def DefinedNode(lparen_loc, value, rparen_loc, keyword_loc, location); end

  # Create a new ElseNode node
  sig do
    params(
      else_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::ElseNode)
  end
  def ElseNode(else_keyword_loc, statements, end_keyword_loc, location); end

  # Create a new EmbeddedStatementsNode node
  sig do
    params(
      opening_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      closing_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::EmbeddedStatementsNode)
  end
  def EmbeddedStatementsNode(opening_loc, statements, closing_loc, location); end

  # Create a new EmbeddedVariableNode node
  sig do
    params(
      operator_loc: Prism::Location,
      variable: Prism::Node,
      location: Prism::Location
    ).returns(Prism::EmbeddedVariableNode)
  end
  def EmbeddedVariableNode(operator_loc, variable, location); end

  # Create a new EnsureNode node
  sig do
    params(
      ensure_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::EnsureNode)
  end
  def EnsureNode(ensure_keyword_loc, statements, end_keyword_loc, location); end

  # Create a new FalseNode node
  sig { params(location: Prism::Location).returns(Prism::FalseNode) }
  def FalseNode(location); end

  # Create a new FindPatternNode node
  sig do
    params(
      constant: T.nilable(Prism::Node),
      left: Prism::Node,
      requireds: T::Array[Prism::Node],
      right: Prism::Node,
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::FindPatternNode)
  end
  def FindPatternNode(constant, left, requireds, right, opening_loc, closing_loc, location); end

  # Create a new FlipFlopNode node
  sig do
    params(
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::FlipFlopNode)
  end
  def FlipFlopNode(flags, left, right, operator_loc, location); end

  # Create a new FloatNode node
  sig { params(location: Prism::Location).returns(Prism::FloatNode) }
  def FloatNode(location); end

  # Create a new ForNode node
  sig do
    params(
      index: Prism::Node,
      collection: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      for_keyword_loc: Prism::Location,
      in_keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::ForNode)
  end
  def ForNode(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end

  # Create a new ForwardingArgumentsNode node
  sig { params(location: Prism::Location).returns(Prism::ForwardingArgumentsNode) }
  def ForwardingArgumentsNode(location); end

  # Create a new ForwardingParameterNode node
  sig { params(location: Prism::Location).returns(Prism::ForwardingParameterNode) }
  def ForwardingParameterNode(location); end

  # Create a new ForwardingSuperNode node
  sig { params(block: T.nilable(Prism::BlockNode), location: Prism::Location).returns(Prism::ForwardingSuperNode) }
  def ForwardingSuperNode(block, location); end

  # Create a new GlobalVariableAndWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::GlobalVariableAndWriteNode)
  end
  def GlobalVariableAndWriteNode(name, name_loc, operator_loc, value, location); end

  # Create a new GlobalVariableOperatorWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).returns(Prism::GlobalVariableOperatorWriteNode)
  end
  def GlobalVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location); end

  # Create a new GlobalVariableOrWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::GlobalVariableOrWriteNode)
  end
  def GlobalVariableOrWriteNode(name, name_loc, operator_loc, value, location); end

  # Create a new GlobalVariableReadNode node
  sig { params(name: Symbol, location: Prism::Location).returns(Prism::GlobalVariableReadNode) }
  def GlobalVariableReadNode(name, location); end

  # Create a new GlobalVariableTargetNode node
  sig { params(name: Symbol, location: Prism::Location).returns(Prism::GlobalVariableTargetNode) }
  def GlobalVariableTargetNode(name, location); end

  # Create a new GlobalVariableWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::GlobalVariableWriteNode)
  end
  def GlobalVariableWriteNode(name, name_loc, value, operator_loc, location); end

  # Create a new HashNode node
  sig do
    params(
      opening_loc: Prism::Location,
      elements: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::HashNode)
  end
  def HashNode(opening_loc, elements, closing_loc, location); end

  # Create a new HashPatternNode node
  sig do
    params(
      constant: T.nilable(Prism::Node),
      elements: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::HashPatternNode)
  end
  def HashPatternNode(constant, elements, rest, opening_loc, closing_loc, location); end

  # Create a new IfNode node
  sig do
    params(
      if_keyword_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      consequent: T.nilable(Prism::Node),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::IfNode)
  end
  def IfNode(if_keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  # Create a new ImaginaryNode node
  sig { params(numeric: Prism::Node, location: Prism::Location).returns(Prism::ImaginaryNode) }
  def ImaginaryNode(numeric, location); end

  # Create a new ImplicitNode node
  sig { params(value: Prism::Node, location: Prism::Location).returns(Prism::ImplicitNode) }
  def ImplicitNode(value, location); end

  # Create a new ImplicitRestNode node
  sig { params(location: Prism::Location).returns(Prism::ImplicitRestNode) }
  def ImplicitRestNode(location); end

  # Create a new InNode node
  sig do
    params(
      pattern: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      in_loc: Prism::Location,
      then_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::InNode)
  end
  def InNode(pattern, statements, in_loc, then_loc, location); end

  # Create a new IndexAndWriteNode node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::IndexAndWriteNode)
  end
  def IndexAndWriteNode(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location); end

  # Create a new IndexOperatorWriteNode node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      operator: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::IndexOperatorWriteNode)
  end
  def IndexOperatorWriteNode(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator, operator_loc, value, location); end

  # Create a new IndexOrWriteNode node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::IndexOrWriteNode)
  end
  def IndexOrWriteNode(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location); end

  # Create a new IndexTargetNode node
  sig do
    params(
      flags: Integer,
      receiver: Prism::Node,
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      location: Prism::Location
    ).returns(Prism::IndexTargetNode)
  end
  def IndexTargetNode(flags, receiver, opening_loc, arguments, closing_loc, block, location); end

  # Create a new InstanceVariableAndWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::InstanceVariableAndWriteNode)
  end
  def InstanceVariableAndWriteNode(name, name_loc, operator_loc, value, location); end

  # Create a new InstanceVariableOperatorWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).returns(Prism::InstanceVariableOperatorWriteNode)
  end
  def InstanceVariableOperatorWriteNode(name, name_loc, operator_loc, value, operator, location); end

  # Create a new InstanceVariableOrWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::InstanceVariableOrWriteNode)
  end
  def InstanceVariableOrWriteNode(name, name_loc, operator_loc, value, location); end

  # Create a new InstanceVariableReadNode node
  sig { params(name: Symbol, location: Prism::Location).returns(Prism::InstanceVariableReadNode) }
  def InstanceVariableReadNode(name, location); end

  # Create a new InstanceVariableTargetNode node
  sig { params(name: Symbol, location: Prism::Location).returns(Prism::InstanceVariableTargetNode) }
  def InstanceVariableTargetNode(name, location); end

  # Create a new InstanceVariableWriteNode node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::InstanceVariableWriteNode)
  end
  def InstanceVariableWriteNode(name, name_loc, value, operator_loc, location); end

  # Create a new IntegerNode node
  sig { params(flags: Integer, location: Prism::Location).returns(Prism::IntegerNode) }
  def IntegerNode(flags, location); end

  # Create a new InterpolatedMatchLastLineNode node
  sig do
    params(
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::InterpolatedMatchLastLineNode)
  end
  def InterpolatedMatchLastLineNode(flags, opening_loc, parts, closing_loc, location); end

  # Create a new InterpolatedRegularExpressionNode node
  sig do
    params(
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::InterpolatedRegularExpressionNode)
  end
  def InterpolatedRegularExpressionNode(flags, opening_loc, parts, closing_loc, location); end

  # Create a new InterpolatedStringNode node
  sig do
    params(
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[Prism::Node],
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::InterpolatedStringNode)
  end
  def InterpolatedStringNode(opening_loc, parts, closing_loc, location); end

  # Create a new InterpolatedSymbolNode node
  sig do
    params(
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[Prism::Node],
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::InterpolatedSymbolNode)
  end
  def InterpolatedSymbolNode(opening_loc, parts, closing_loc, location); end

  # Create a new InterpolatedXStringNode node
  sig do
    params(
      opening_loc: Prism::Location,
      parts: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::InterpolatedXStringNode)
  end
  def InterpolatedXStringNode(opening_loc, parts, closing_loc, location); end

  # Create a new KeywordHashNode node
  sig do
    params(
      flags: Integer,
      elements: T::Array[Prism::Node],
      location: Prism::Location
    ).returns(Prism::KeywordHashNode)
  end
  def KeywordHashNode(flags, elements, location); end

  # Create a new KeywordRestParameterNode node
  sig do
    params(
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::KeywordRestParameterNode)
  end
  def KeywordRestParameterNode(flags, name, name_loc, operator_loc, location); end

  # Create a new LambdaNode node
  sig do
    params(
      locals: T::Array[Symbol],
      operator_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      parameters: T.nilable(Prism::Node),
      body: T.nilable(Prism::Node),
      location: Prism::Location
    ).returns(Prism::LambdaNode)
  end
  def LambdaNode(locals, operator_loc, opening_loc, closing_loc, parameters, body, location); end

  # Create a new LocalVariableAndWriteNode node
  sig do
    params(
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer,
      location: Prism::Location
    ).returns(Prism::LocalVariableAndWriteNode)
  end
  def LocalVariableAndWriteNode(name_loc, operator_loc, value, name, depth, location); end

  # Create a new LocalVariableOperatorWriteNode node
  sig do
    params(
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      operator: Symbol,
      depth: Integer,
      location: Prism::Location
    ).returns(Prism::LocalVariableOperatorWriteNode)
  end
  def LocalVariableOperatorWriteNode(name_loc, operator_loc, value, name, operator, depth, location); end

  # Create a new LocalVariableOrWriteNode node
  sig do
    params(
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer,
      location: Prism::Location
    ).returns(Prism::LocalVariableOrWriteNode)
  end
  def LocalVariableOrWriteNode(name_loc, operator_loc, value, name, depth, location); end

  # Create a new LocalVariableReadNode node
  sig { params(name: Symbol, depth: Integer, location: Prism::Location).returns(Prism::LocalVariableReadNode) }
  def LocalVariableReadNode(name, depth, location); end

  # Create a new LocalVariableTargetNode node
  sig { params(name: Symbol, depth: Integer, location: Prism::Location).returns(Prism::LocalVariableTargetNode) }
  def LocalVariableTargetNode(name, depth, location); end

  # Create a new LocalVariableWriteNode node
  sig do
    params(
      name: Symbol,
      depth: Integer,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::LocalVariableWriteNode)
  end
  def LocalVariableWriteNode(name, depth, name_loc, value, operator_loc, location); end

  # Create a new Location object
  sig { params(source: T.nilable(Prism::Source), start_offset: Integer, length: Integer).returns(Prism::Location) }
  def Location(source, start_offset, length); end

  # Create a new MatchLastLineNode node
  sig do
    params(
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String,
      location: Prism::Location
    ).returns(Prism::MatchLastLineNode)
  end
  def MatchLastLineNode(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # Create a new MatchPredicateNode node
  sig do
    params(
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::MatchPredicateNode)
  end
  def MatchPredicateNode(value, pattern, operator_loc, location); end

  # Create a new MatchRequiredNode node
  sig do
    params(
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::MatchRequiredNode)
  end
  def MatchRequiredNode(value, pattern, operator_loc, location); end

  # Create a new MatchWriteNode node
  sig do
    params(
      call: Prism::CallNode,
      targets: T::Array[Prism::Node],
      location: Prism::Location
    ).returns(Prism::MatchWriteNode)
  end
  def MatchWriteNode(call, targets, location); end

  # Create a new MissingNode node
  sig { params(location: Prism::Location).returns(Prism::MissingNode) }
  def MissingNode(location); end

  # Create a new ModuleNode node
  sig do
    params(
      locals: T::Array[Symbol],
      module_keyword_loc: Prism::Location,
      constant_path: Prism::Node,
      body: T.nilable(Prism::Node),
      end_keyword_loc: Prism::Location,
      name: Symbol,
      location: Prism::Location
    ).returns(Prism::ModuleNode)
  end
  def ModuleNode(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location); end

  # Create a new MultiTargetNode node
  sig do
    params(
      lefts: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      rights: T::Array[Prism::Node],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::MultiTargetNode)
  end
  def MultiTargetNode(lefts, rest, rights, lparen_loc, rparen_loc, location); end

  # Create a new MultiWriteNode node
  sig do
    params(
      lefts: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      rights: T::Array[Prism::Node],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::MultiWriteNode)
  end
  def MultiWriteNode(lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value, location); end

  # Create a new NextNode node
  sig do
    params(
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::NextNode)
  end
  def NextNode(arguments, keyword_loc, location); end

  # Create a new NilNode node
  sig { params(location: Prism::Location).returns(Prism::NilNode) }
  def NilNode(location); end

  # Create a new NoKeywordsParameterNode node
  sig do
    params(
      operator_loc: Prism::Location,
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::NoKeywordsParameterNode)
  end
  def NoKeywordsParameterNode(operator_loc, keyword_loc, location); end

  # Create a new NumberedParametersNode node
  sig { params(maximum: Integer, location: Prism::Location).returns(Prism::NumberedParametersNode) }
  def NumberedParametersNode(maximum, location); end

  # Create a new NumberedReferenceReadNode node
  sig { params(number: Integer, location: Prism::Location).returns(Prism::NumberedReferenceReadNode) }
  def NumberedReferenceReadNode(number, location); end

  # Create a new OptionalKeywordParameterNode node
  sig do
    params(
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::OptionalKeywordParameterNode)
  end
  def OptionalKeywordParameterNode(flags, name, name_loc, value, location); end

  # Create a new OptionalParameterNode node
  sig do
    params(
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).returns(Prism::OptionalParameterNode)
  end
  def OptionalParameterNode(flags, name, name_loc, operator_loc, value, location); end

  # Create a new OrNode node
  sig do
    params(
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::OrNode)
  end
  def OrNode(left, right, operator_loc, location); end

  # Create a new ParametersNode node
  sig do
    params(
      requireds: T::Array[Prism::Node],
      optionals: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      keywords: T::Array[Prism::Node],
      keyword_rest: T.nilable(Prism::Node),
      block: T.nilable(Prism::BlockParameterNode),
      location: Prism::Location
    ).returns(Prism::ParametersNode)
  end
  def ParametersNode(requireds, optionals, rest, posts, keywords, keyword_rest, block, location); end

  # Create a new ParenthesesNode node
  sig do
    params(
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::ParenthesesNode)
  end
  def ParenthesesNode(body, opening_loc, closing_loc, location); end

  # Create a new PinnedExpressionNode node
  sig do
    params(
      expression: Prism::Node,
      operator_loc: Prism::Location,
      lparen_loc: Prism::Location,
      rparen_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::PinnedExpressionNode)
  end
  def PinnedExpressionNode(expression, operator_loc, lparen_loc, rparen_loc, location); end

  # Create a new PinnedVariableNode node
  sig do
    params(
      variable: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::PinnedVariableNode)
  end
  def PinnedVariableNode(variable, operator_loc, location); end

  # Create a new PostExecutionNode node
  sig do
    params(
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::PostExecutionNode)
  end
  def PostExecutionNode(statements, keyword_loc, opening_loc, closing_loc, location); end

  # Create a new PreExecutionNode node
  sig do
    params(
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::PreExecutionNode)
  end
  def PreExecutionNode(statements, keyword_loc, opening_loc, closing_loc, location); end

  # Create a new ProgramNode node
  sig do
    params(
      locals: T::Array[Symbol],
      statements: Prism::StatementsNode,
      location: Prism::Location
    ).returns(Prism::ProgramNode)
  end
  def ProgramNode(locals, statements, location); end

  # Create a new RangeNode node
  sig do
    params(
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::RangeNode)
  end
  def RangeNode(flags, left, right, operator_loc, location); end

  # Create a new RationalNode node
  sig { params(numeric: Prism::Node, location: Prism::Location).returns(Prism::RationalNode) }
  def RationalNode(numeric, location); end

  # Create a new RedoNode node
  sig { params(location: Prism::Location).returns(Prism::RedoNode) }
  def RedoNode(location); end

  # Create a new RegularExpressionNode node
  sig do
    params(
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String,
      location: Prism::Location
    ).returns(Prism::RegularExpressionNode)
  end
  def RegularExpressionNode(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # Create a new RequiredKeywordParameterNode node
  sig do
    params(
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::RequiredKeywordParameterNode)
  end
  def RequiredKeywordParameterNode(flags, name, name_loc, location); end

  # Create a new RequiredParameterNode node
  sig { params(flags: Integer, name: Symbol, location: Prism::Location).returns(Prism::RequiredParameterNode) }
  def RequiredParameterNode(flags, name, location); end

  # Create a new RescueModifierNode node
  sig do
    params(
      expression: Prism::Node,
      keyword_loc: Prism::Location,
      rescue_expression: Prism::Node,
      location: Prism::Location
    ).returns(Prism::RescueModifierNode)
  end
  def RescueModifierNode(expression, keyword_loc, rescue_expression, location); end

  # Create a new RescueNode node
  sig do
    params(
      keyword_loc: Prism::Location,
      exceptions: T::Array[Prism::Node],
      operator_loc: T.nilable(Prism::Location),
      reference: T.nilable(Prism::Node),
      statements: T.nilable(Prism::StatementsNode),
      consequent: T.nilable(Prism::RescueNode),
      location: Prism::Location
    ).returns(Prism::RescueNode)
  end
  def RescueNode(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location); end

  # Create a new RestParameterNode node
  sig do
    params(
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::RestParameterNode)
  end
  def RestParameterNode(flags, name, name_loc, operator_loc, location); end

  # Create a new RetryNode node
  sig { params(location: Prism::Location).returns(Prism::RetryNode) }
  def RetryNode(location); end

  # Create a new ReturnNode node
  sig do
    params(
      keyword_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      location: Prism::Location
    ).returns(Prism::ReturnNode)
  end
  def ReturnNode(keyword_loc, arguments, location); end

  # Create a new SelfNode node
  sig { params(location: Prism::Location).returns(Prism::SelfNode) }
  def SelfNode(location); end

  # Create a new SingletonClassNode node
  sig do
    params(
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      operator_loc: Prism::Location,
      expression: Prism::Node,
      body: T.nilable(Prism::Node),
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::SingletonClassNode)
  end
  def SingletonClassNode(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location); end

  # Create a new SourceEncodingNode node
  sig { params(location: Prism::Location).returns(Prism::SourceEncodingNode) }
  def SourceEncodingNode(location); end

  # Create a new SourceFileNode node
  sig { params(filepath: String, location: Prism::Location).returns(Prism::SourceFileNode) }
  def SourceFileNode(filepath, location); end

  # Create a new SourceLineNode node
  sig { params(location: Prism::Location).returns(Prism::SourceLineNode) }
  def SourceLineNode(location); end

  # Create a new SplatNode node
  sig do
    params(
      operator_loc: Prism::Location,
      expression: T.nilable(Prism::Node),
      location: Prism::Location
    ).returns(Prism::SplatNode)
  end
  def SplatNode(operator_loc, expression, location); end

  # Create a new StatementsNode node
  sig { params(body: T::Array[Prism::Node], location: Prism::Location).returns(Prism::StatementsNode) }
  def StatementsNode(body, location); end

  # Create a new StringNode node
  sig do
    params(
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      content_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      unescaped: String,
      location: Prism::Location
    ).returns(Prism::StringNode)
  end
  def StringNode(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # Create a new SuperNode node
  sig do
    params(
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      block: T.nilable(Prism::Node),
      location: Prism::Location
    ).returns(Prism::SuperNode)
  end
  def SuperNode(keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end

  # Create a new SymbolNode node
  sig do
    params(
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      value_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      unescaped: String,
      location: Prism::Location
    ).returns(Prism::SymbolNode)
  end
  def SymbolNode(flags, opening_loc, value_loc, closing_loc, unescaped, location); end

  # Create a new TrueNode node
  sig { params(location: Prism::Location).returns(Prism::TrueNode) }
  def TrueNode(location); end

  # Create a new UndefNode node
  sig do
    params(
      names: T::Array[Prism::Node],
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).returns(Prism::UndefNode)
  end
  def UndefNode(names, keyword_loc, location); end

  # Create a new UnlessNode node
  sig do
    params(
      keyword_loc: Prism::Location,
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      consequent: T.nilable(Prism::ElseNode),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::UnlessNode)
  end
  def UnlessNode(keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  # Create a new UntilNode node
  sig do
    params(
      flags: Integer,
      keyword_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      location: Prism::Location
    ).returns(Prism::UntilNode)
  end
  def UntilNode(flags, keyword_loc, closing_loc, predicate, statements, location); end

  # Create a new WhenNode node
  sig do
    params(
      keyword_loc: Prism::Location,
      conditions: T::Array[Prism::Node],
      statements: T.nilable(Prism::StatementsNode),
      location: Prism::Location
    ).returns(Prism::WhenNode)
  end
  def WhenNode(keyword_loc, conditions, statements, location); end

  # Create a new WhileNode node
  sig do
    params(
      flags: Integer,
      keyword_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      location: Prism::Location
    ).returns(Prism::WhileNode)
  end
  def WhileNode(flags, keyword_loc, closing_loc, predicate, statements, location); end

  # Create a new XStringNode node
  sig do
    params(
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String,
      location: Prism::Location
    ).returns(Prism::XStringNode)
  end
  def XStringNode(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  # Create a new YieldNode node
  sig do
    params(
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).returns(Prism::YieldNode)
  end
  def YieldNode(keyword_loc, lparen_loc, arguments, rparen_loc, location); end
end

# Represents a method definition.
#
#     def method
#     end
#     ^^^^^^^^^^
class Prism::DefNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      receiver: T.nilable(Prism::Node),
      parameters: T.nilable(Prism::ParametersNode),
      body: T.nilable(Prism::Node),
      locals: T::Array[Symbol],
      def_keyword_loc: Prism::Location,
      operator_loc: T.nilable(Prism::Location),
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::DefNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def def_keyword; end

  sig { returns(Prism::Location) }
  def def_keyword_loc; end

  sig { returns(T.nilable(String)) }
  def end_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { returns(T.nilable(String)) }
  def equal; end

  sig { returns(T.nilable(Prism::Location)) }
  def equal_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(T.nilable(String)) }
  def operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::ParametersNode)) }
  def parameters; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end
end

# Represents the use of the `defined?` keyword.
#
#     defined?(a)
#     ^^^^^^^^^^^
class Prism::DefinedNode < Prism::Node
  sig do
    params(
      lparen_loc: T.nilable(Prism::Location),
      value: Prism::Node,
      rparen_loc: T.nilable(Prism::Location),
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(lparen_loc, value, rparen_loc, keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::DefinedNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents an `else` clause in a `case`, `if`, or `unless` statement.
#
#     if a then b else c end
#                 ^^^^^^^^^^
class Prism::ElseNode < Prism::Node
  sig do
    params(
      else_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(else_keyword_loc, statements, end_keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ElseNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def else_keyword; end

  sig { returns(Prism::Location) }
  def else_keyword_loc; end

  sig { returns(T.nilable(String)) }
  def end_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

class Prism::EmbDocComment < Prism::Comment; end

# Represents an interpolated set of statements.
#
#     "foo #{bar}"
#          ^^^^^^
class Prism::EmbeddedStatementsNode < Prism::Node
  sig do
    params(
      opening_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, statements, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::EmbeddedStatementsNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

# Represents an interpolated variable.
#
#     "foo #@bar"
#          ^^^^^
class Prism::EmbeddedVariableNode < Prism::Node
  sig { params(operator_loc: Prism::Location, variable: Prism::Node, location: Prism::Location).void }
  def initialize(operator_loc, variable, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::EmbeddedVariableNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def variable; end
end

# Flags for nodes that have unescaped content.
module Prism::EncodingFlags
  # internal bytes forced the encoding to binary
  FORCED_BINARY_ENCODING = T.let(1 << 1, Integer)

  # internal bytes forced the encoding to UTF-8
  FORCED_UTF8_ENCODING = T.let(1 << 0, Integer)
end

# Represents an `ensure` clause in a `begin` statement.
#
#     begin
#       foo
#     ensure
#     ^^^^^^
#       bar
#     end
class Prism::EnsureNode < Prism::Node
  sig do
    params(
      ensure_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(ensure_keyword_loc, statements, end_keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::EnsureNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { returns(String) }
  def ensure_keyword; end

  sig { returns(Prism::Location) }
  def ensure_keyword_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

# Represents the use of the literal `false` keyword.
#
#     false
#     ^^^^^
class Prism::FalseNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::FalseNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents a find pattern in pattern matching.
#
#     foo in *bar, baz, *qux
#            ^^^^^^^^^^^^^^^
#
#     foo in [*bar, baz, *qux]
#            ^^^^^^^^^^^^^^^^^
#
#     foo in Foo(*bar, baz, *qux)
#            ^^^^^^^^^^^^^^^^^^^^
class Prism::FindPatternNode < Prism::Node
  sig do
    params(
      constant: T.nilable(Prism::Node),
      left: Prism::Node,
      requireds: T::Array[Prism::Node],
      right: Prism::Node,
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(constant, left, requireds, right, opening_loc, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def constant; end

  sig { params(params: T.untyped).returns(Prism::FindPatternNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Prism::Node) }
  def left; end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  sig { returns(Prism::Node) }
  def right; end
end

# Represents the use of the `..` or `...` operators to create flip flops.
#
#     baz if foo .. bar
#            ^^^^^^^^^^
class Prism::FlipFlopNode < Prism::Node
  sig do
    params(
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(flags, left, right, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::FlipFlopNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def exclude_end?; end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::Node)) }
  def left; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def right; end
end

# Represents a floating point number literal.
#
#     1.0
#     ^^^
class Prism::FloatNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::FloatNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of the `for` keyword.
#
#     for i in a end
#     ^^^^^^^^^^^^^^
class Prism::ForNode < Prism::Node
  sig do
    params(
      index: Prism::Node,
      collection: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      for_keyword_loc: Prism::Location,
      in_keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(Prism::Node) }
  def collection; end

  sig { params(params: T.untyped).returns(Prism::ForNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(String)) }
  def do_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def do_keyword_loc; end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { returns(String) }
  def for_keyword; end

  sig { returns(Prism::Location) }
  def for_keyword_loc; end

  sig { returns(String) }
  def in_keyword; end

  sig { returns(Prism::Location) }
  def in_keyword_loc; end

  sig { returns(Prism::Node) }
  def index; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

# Represents forwarding all arguments to this method to another method.
#
#     def foo(...)
#       bar(...)
#           ^^^
#     end
class Prism::ForwardingArgumentsNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ForwardingArgumentsNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of the forwarding parameter in a method, block, or lambda declaration.
#
#     def foo(...)
#             ^^^
#     end
class Prism::ForwardingParameterNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ForwardingParameterNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of the `super` keyword without parentheses or arguments.
#
#     super
#     ^^^^^
class Prism::ForwardingSuperNode < Prism::Node
  sig { params(block: T.nilable(Prism::BlockNode), location: Prism::Location).void }
  def initialize(block, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::BlockNode)) }
  def block; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ForwardingSuperNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of the `&&=` operator for assignment to a global variable.
#
#     $target &&= value
#     ^^^^^^^^^^^^^^^^^
class Prism::GlobalVariableAndWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::GlobalVariableAndWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents assigning to a global variable using an operator that isn't `=`.
#
#     $target += value
#     ^^^^^^^^^^^^^^^^
class Prism::GlobalVariableOperatorWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::GlobalVariableOperatorWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(Symbol) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of the `||=` operator for assignment to a global variable.
#
#     $target ||= value
#     ^^^^^^^^^^^^^^^^^
class Prism::GlobalVariableOrWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::GlobalVariableOrWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents referencing a global variable.
#
#     $foo
#     ^^^^
class Prism::GlobalVariableReadNode < Prism::Node
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::GlobalVariableReadNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

# Represents writing to a global variable in a context that doesn't have an explicit value.
#
#     $foo, $bar = baz
#     ^^^^  ^^^^
class Prism::GlobalVariableTargetNode < Prism::Node
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::GlobalVariableTargetNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

# Represents writing to a global variable.
#
#     $foo = 1
#     ^^^^^^^^
class Prism::GlobalVariableWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, value, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::GlobalVariableWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents a hash literal.
#
#     { a => b }
#     ^^^^^^^^^^
class Prism::HashNode < Prism::Node
  sig do
    params(
      opening_loc: Prism::Location,
      elements: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, elements, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::HashNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end
end

# Represents a hash pattern in pattern matching.
#
#     foo => { a: 1, b: 2 }
#            ^^^^^^^^^^^^^^
#
#     foo => { a: 1, b: 2, **c }
#            ^^^^^^^^^^^^^^^^^^^
class Prism::HashPatternNode < Prism::Node
  sig do
    params(
      constant: T.nilable(Prism::Node),
      elements: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(constant, elements, rest, opening_loc, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def constant; end

  sig { params(params: T.untyped).returns(Prism::HashPatternNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def rest; end
end

# Represents the use of the `if` keyword, either in the block form or the modifier form.
#
#     bar if foo
#     ^^^^^^^^^^
#
#     if foo then bar end
#     ^^^^^^^^^^^^^^^^^^^
class Prism::IfNode < Prism::Node
  sig do
    params(
      if_keyword_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      consequent: T.nilable(Prism::Node),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(if_keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(Prism::Node)) }
  def consequent; end

  sig { params(params: T.untyped).returns(Prism::IfNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(String)) }
  def end_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { returns(T.nilable(String)) }
  def if_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def if_keyword_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Prism::Node) }
  def predicate; end

  def set_newline_flag(newline_marked); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { returns(T.nilable(String)) }
  def then_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end
end

# Represents an imaginary number literal.
#
#     1.0i
#     ^^^^
class Prism::ImaginaryNode < Prism::Node
  sig { params(numeric: Prism::Node, location: Prism::Location).void }
  def initialize(numeric, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ImaginaryNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Prism::Node) }
  def numeric; end
end

# Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.
#
#     { foo: }
#       ^^^^
#
#     { Foo: }
#       ^^^^
#
#     foo in { bar: }
#              ^^^^
class Prism::ImplicitNode < Prism::Node
  sig { params(value: Prism::Node, location: Prism::Location).void }
  def initialize(value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ImplicitNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents using a trailing comma to indicate an implicit rest parameter.
#
#     foo { |bar,| }
#               ^
#
#     foo in [bar,]
#                ^
#
#     for foo, in bar do end
#            ^
#
#     foo, = bar
#        ^
class Prism::ImplicitRestNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ImplicitRestNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of the `in` keyword in a case statement.
#
#     case a; in b then c end
#             ^^^^^^^^^^^
class Prism::InNode < Prism::Node
  sig do
    params(
      pattern: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      in_loc: Prism::Location,
      then_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(pattern, statements, in_loc, then_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::InNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def in; end

  sig { returns(Prism::Location) }
  def in_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Prism::Node) }
  def pattern; end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { returns(T.nilable(String)) }
  def then; end

  sig { returns(T.nilable(Prism::Location)) }
  def then_loc; end
end

# Represents the use of the `&&=` operator on a call to the `[]` method.
#
#     foo.bar[baz] &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^
class Prism::IndexAndWriteNode < Prism::Node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::IndexAndWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end
end

# Represents the use of an assignment operator on a call to `[]`.
#
#     foo.bar[baz] += value
#     ^^^^^^^^^^^^^^^^^^^^^
class Prism::IndexOperatorWriteNode < Prism::Node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      operator: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::IndexOperatorWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Symbol) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end
end

# Represents the use of the `||=` operator on a call to `[]`.
#
#     foo.bar[baz] ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^
class Prism::IndexOrWriteNode < Prism::Node
  sig do
    params(
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  sig { returns(T.nilable(String)) }
  def call_operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::IndexOrWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  sig { returns(Prism::Node) }
  def value; end

  sig { returns(T::Boolean) }
  def variable_call?; end
end

# Represents assigning to an index.
#
#     foo[bar], = 1
#     ^^^^^^^^
#
#     begin
#     rescue => foo[bar]
#               ^^^^^^^^
#     end
#
#     for foo[bar] in baz do end
#         ^^^^^^^^
class Prism::IndexTargetNode < Prism::Node
  sig do
    params(
      flags: Integer,
      receiver: Prism::Node,
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::Node),
      location: Prism::Location
    ).void
  end
  def initialize(flags, receiver, opening_loc, arguments, closing_loc, block, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Boolean) }
  def attribute_write?; end

  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::IndexTargetNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Prism::Node) }
  def receiver; end

  sig { returns(T::Boolean) }
  def safe_navigation?; end

  sig { returns(T::Boolean) }
  def variable_call?; end
end

class Prism::InlineComment < Prism::Comment
  sig { override.returns(T::Boolean) }
  def trailing?; end
end

# Represents the use of the `&&=` operator for assignment to an instance variable.
#
#     @target &&= value
#     ^^^^^^^^^^^^^^^^^
class Prism::InstanceVariableAndWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::InstanceVariableAndWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents assigning to an instance variable using an operator that isn't `=`.
#
#     @target += value
#     ^^^^^^^^^^^^^^^^
class Prism::InstanceVariableOperatorWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      operator: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, operator, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::InstanceVariableOperatorWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(Symbol) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of the `||=` operator for assignment to an instance variable.
#
#     @target ||= value
#     ^^^^^^^^^^^^^^^^^
class Prism::InstanceVariableOrWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::InstanceVariableOrWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents referencing an instance variable.
#
#     @foo
#     ^^^^
class Prism::InstanceVariableReadNode < Prism::Node
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::InstanceVariableReadNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

# Represents writing to an instance variable in a context that doesn't have an explicit value.
#
#     @foo, @bar = baz
#     ^^^^  ^^^^
class Prism::InstanceVariableTargetNode < Prism::Node
  sig { params(name: Symbol, location: Prism::Location).void }
  def initialize(name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::InstanceVariableTargetNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

# Represents writing to an instance variable.
#
#     @foo = 1
#     ^^^^^^^^
class Prism::InstanceVariableWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, name_loc, value, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::InstanceVariableWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Flags for integer nodes that correspond to the base of the integer.
module Prism::IntegerBaseFlags
  # 0b prefix
  BINARY = T.let(1 << 0, Integer)

  # 0d or no prefix
  DECIMAL = T.let(1 << 1, Integer)

  # 0x prefix
  HEXADECIMAL = T.let(1 << 3, Integer)

  # 0o or 0 prefix
  OCTAL = T.let(1 << 2, Integer)
end

# Represents an integer number literal.
#
#     1
#     ^
class Prism::IntegerNode < Prism::Node
  sig { params(flags: Integer, location: Prism::Location).void }
  def initialize(flags, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def binary?; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::IntegerNode) }
  def copy(**params); end

  sig { returns(T::Boolean) }
  def decimal?; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def hexadecimal?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Boolean) }
  def octal?; end
end

# Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.
#
#     if /foo #{bar} baz/ then end
#        ^^^^^^^^^^^^^^^^
class Prism::InterpolatedMatchLastLineNode < Prism::Node
  sig do
    params(
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(flags, opening_loc, parts, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::InterpolatedMatchLastLineNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def euc_jp?; end

  sig { returns(T::Boolean) }
  def extended?; end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def ignore_case?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Boolean) }
  def multi_line?; end

  sig { returns(T::Boolean) }
  def once?; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  def set_newline_flag(newline_marked); end

  sig { returns(T::Boolean) }
  def utf_8?; end

  sig { returns(T::Boolean) }
  def windows_31j?; end
end

# Represents a regular expression literal that contains interpolation.
#
#     /foo #{bar} baz/
#     ^^^^^^^^^^^^^^^^
class Prism::InterpolatedRegularExpressionNode < Prism::Node
  sig do
    params(
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(flags, opening_loc, parts, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::InterpolatedRegularExpressionNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def euc_jp?; end

  sig { returns(T::Boolean) }
  def extended?; end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def ignore_case?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Boolean) }
  def multi_line?; end

  sig { returns(T::Boolean) }
  def once?; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  def set_newline_flag(newline_marked); end

  sig { returns(T::Boolean) }
  def utf_8?; end

  sig { returns(T::Boolean) }
  def windows_31j?; end
end

# Represents a string literal that contains interpolation.
#
#     "foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^
class Prism::InterpolatedStringNode < Prism::Node
  sig do
    params(
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[Prism::Node],
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, parts, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::InterpolatedStringNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  def set_newline_flag(newline_marked); end
end

# Represents a symbol literal that contains interpolation.
#
#     :"foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^^
class Prism::InterpolatedSymbolNode < Prism::Node
  sig do
    params(
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[Prism::Node],
      closing_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, parts, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::InterpolatedSymbolNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  def set_newline_flag(newline_marked); end
end

# Represents an xstring literal that contains interpolation.
#
#     `foo #{bar} baz`
#     ^^^^^^^^^^^^^^^^
class Prism::InterpolatedXStringNode < Prism::Node
  sig do
    params(
      opening_loc: Prism::Location,
      parts: T::Array[Prism::Node],
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(opening_loc, parts, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::InterpolatedXStringNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(T::Array[Prism::Node]) }
  def parts; end

  def set_newline_flag(newline_marked); end
end

# Represents a hash literal without opening and closing braces.
#
#     foo(a: b)
#         ^^^^
class Prism::KeywordHashNode < Prism::Node
  sig { params(flags: Integer, elements: T::Array[Prism::Node], location: Prism::Location).void }
  def initialize(flags, elements, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::KeywordHashNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Boolean) }
  def symbol_keys?; end
end

# Flags for keyword hash nodes.
module Prism::KeywordHashNodeFlags
  # a keyword hash which only has `AssocNode` elements all with symbol keys, which means the elements can be treated as keyword arguments
  SYMBOL_KEYS = T.let(1 << 0, Integer)
end

# Represents a keyword rest parameter to a method, block, or lambda definition.
#
#     def a(**b)
#           ^^^
#     end
class Prism::KeywordRestParameterNode < Prism::Node
  sig do
    params(
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(flags, name, name_loc, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::KeywordRestParameterNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Symbol)) }
  def name; end

  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end
end

# Represents using a lambda literal (not the lambda method call).
#
#     ->(value) { value * 2 }
#     ^^^^^^^^^^^^^^^^^^^^^^^
class Prism::LambdaNode < Prism::Node
  sig do
    params(
      locals: T::Array[Symbol],
      operator_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      parameters: T.nilable(Prism::Node),
      body: T.nilable(Prism::Node),
      location: Prism::Location
    ).void
  end
  def initialize(locals, operator_loc, opening_loc, closing_loc, parameters, body, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::LambdaNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def parameters; end
end

# Represents the use of the `&&=` operator for assignment to a local variable.
#
#     target &&= value
#     ^^^^^^^^^^^^^^^^
class Prism::LocalVariableAndWriteNode < Prism::Node
  sig do
    params(
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(name_loc, operator_loc, value, name, depth, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::LocalVariableAndWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents assigning to a local variable using an operator that isn't `=`.
#
#     target += value
#     ^^^^^^^^^^^^^^^
class Prism::LocalVariableOperatorWriteNode < Prism::Node
  sig do
    params(
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      operator: Symbol,
      depth: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(name_loc, operator_loc, value, name, operator, depth, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::LocalVariableOperatorWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(Symbol) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of the `||=` operator for assignment to a local variable.
#
#     target ||= value
#     ^^^^^^^^^^^^^^^^
class Prism::LocalVariableOrWriteNode < Prism::Node
  sig do
    params(
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer,
      location: Prism::Location
    ).void
  end
  def initialize(name_loc, operator_loc, value, name, depth, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::LocalVariableOrWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.
#
#     foo
#     ^^^
class Prism::LocalVariableReadNode < Prism::Node
  sig { params(name: Symbol, depth: Integer, location: Prism::Location).void }
  def initialize(name, depth, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::LocalVariableReadNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

# Represents writing to a local variable in a context that doesn't have an explicit value.
#
#     foo, bar = baz
#     ^^^  ^^^
class Prism::LocalVariableTargetNode < Prism::Node
  sig { params(name: Symbol, depth: Integer, location: Prism::Location).void }
  def initialize(name, depth, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::LocalVariableTargetNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end
end

# Represents writing to a local variable.
#
#     foo = 1
#     ^^^^^^^
class Prism::LocalVariableWriteNode < Prism::Node
  sig do
    params(
      name: Symbol,
      depth: Integer,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(name, depth, name_loc, value, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::LocalVariableWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def depth; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

class Prism::Location
  sig { params(source: Prism::Source, start_offset: Integer, length: Integer).void }
  def initialize(source, start_offset, length); end

  sig { returns(T::Array[Prism::Comment]) }
  def comments; end

  sig { params(options: T.untyped).returns(Prism::Location) }
  def copy(**options); end

  sig { returns(Integer) }
  def end_column; end

  sig { returns(Integer) }
  def end_line; end

  sig { returns(Integer) }
  def end_offset; end

  sig { returns(String) }
  def slice; end

  sig { returns(Integer) }
  def start_column; end

  sig { returns(Integer) }
  def start_line; end

  sig { returns(Integer) }
  def start_offset; end
end

# Flags for while and until loop nodes.
module Prism::LoopFlags
  # a loop after a begin statement, so the body is executed first before the condition
  BEGIN_MODIFIER = T.let(1 << 0, Integer)
end

# Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.
#
#     if /foo/i then end
#        ^^^^^^
class Prism::MatchLastLineNode < Prism::Node
  sig do
    params(
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String,
      location: Prism::Location
    ).void
  end
  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { returns(String) }
  def content; end

  sig { returns(Prism::Location) }
  def content_loc; end

  sig { params(params: T.untyped).returns(Prism::MatchLastLineNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def euc_jp?; end

  sig { returns(T::Boolean) }
  def extended?; end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def ignore_case?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Boolean) }
  def multi_line?; end

  sig { returns(T::Boolean) }
  def once?; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(String) }
  def unescaped; end

  sig { returns(T::Boolean) }
  def utf_8?; end

  sig { returns(T::Boolean) }
  def windows_31j?; end
end

# Represents the use of the modifier `in` operator.
#
#     foo in bar
#     ^^^^^^^^^^
class Prism::MatchPredicateNode < Prism::Node
  sig do
    params(
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(value, pattern, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::MatchPredicateNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def pattern; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of the `=>` operator.
#
#     foo => bar
#     ^^^^^^^^^^
class Prism::MatchRequiredNode < Prism::Node
  sig do
    params(
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(value, pattern, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::MatchRequiredNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def pattern; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents writing local variables using a regular expression match with named capture groups.
#
#     /(?<foo>bar)/ =~ baz
#     ^^^^^^^^^^^^^^^^^^^^
class Prism::MatchWriteNode < Prism::Node
  sig { params(call: Prism::CallNode, targets: T::Array[Prism::Node], location: Prism::Location).void }
  def initialize(call, targets, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(Prism::CallNode) }
  def call; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::MatchWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Prism::Node]) }
  def targets; end
end

# Represents a node that is missing from the source and results in a syntax error.
class Prism::MissingNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::MissingNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents a module declaration involving the `module` keyword.
#
#     module Foo end
#     ^^^^^^^^^^^^^^
class Prism::ModuleNode < Prism::Node
  sig do
    params(
      locals: T::Array[Symbol],
      module_keyword_loc: Prism::Location,
      constant_path: Prism::Node,
      body: T.nilable(Prism::Node),
      end_keyword_loc: Prism::Location,
      name: Symbol,
      location: Prism::Location
    ).void
  end
  def initialize(locals, module_keyword_loc, constant_path, body, end_keyword_loc, name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(Prism::Node) }
  def constant_path; end

  sig { params(params: T.untyped).returns(Prism::ModuleNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(String) }
  def module_keyword; end

  sig { returns(Prism::Location) }
  def module_keyword_loc; end

  sig { returns(Symbol) }
  def name; end
end

# Represents a multi-target expression.
#
#     a, (b, c) = 1, 2, 3
#        ^^^^^^
class Prism::MultiTargetNode < Prism::Node
  sig do
    params(
      lefts: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      rights: T::Array[Prism::Node],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(lefts, rest, rights, lparen_loc, rparen_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::MultiTargetNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Prism::Node]) }
  def lefts; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  sig { returns(T::Array[Prism::Node]) }
  def rights; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end
end

# Represents a write to a multi-target expression.
#
#     a, b, c = 1, 2, 3
#     ^^^^^^^^^^^^^^^^^
class Prism::MultiWriteNode < Prism::Node
  sig do
    params(
      lefts: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      rights: T::Array[Prism::Node],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::MultiWriteNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Prism::Node]) }
  def lefts; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  sig { returns(T::Array[Prism::Node]) }
  def rights; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of the `next` keyword.
#
#     next 1
#     ^^^^^^
class Prism::NextNode < Prism::Node
  sig do
    params(
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(arguments, keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::NextNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end
end

# Represents the use of the `nil` keyword.
#
#     nil
#     ^^^
class Prism::NilNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::NilNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of `**nil` inside method arguments.
#
#     def a(**nil)
#           ^^^^^
#     end
class Prism::NoKeywordsParameterNode < Prism::Node
  sig { params(operator_loc: Prism::Location, keyword_loc: Prism::Location, location: Prism::Location).void }
  def initialize(operator_loc, keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::NoKeywordsParameterNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end
end

class Prism::Node
  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig { returns(Prism::Location) }
  def location; end

  sig { returns(String) }
  def slice; end

  sig { returns(String) }
  def to_dot; end

  sig { returns(Symbol) }
  def type; end
end

class Prism::NodeInspector
  sig { params(prefix: String).void }
  def initialize(prefix); end

  # Appends a line to the output with the current prefix.
  sig { params(line: String).void }
  def <<(line); end

  # Returns a new inspector that can be used to inspect a child node.
  sig { params(append: String).returns(Prism::NodeInspector) }
  def child_inspector(append); end

  # Generates a string that represents a child node.
  sig { params(node: Prism::Node, append: String).returns(String) }
  def child_node(node, append); end

  # This generates a string that is used as the header of the inspect output
  # for any given node.
  sig { params(node: Prism::Node).returns(String) }
  def header(node); end

  # Generates a string that represents a list of nodes. It handles properly
  # using the box drawing characters to make the output look nice.
  sig { params(prefix: String, nodes: T::Array[Prism::Node]).returns(String) }
  def list(prefix, nodes); end

  # Generates a string that represents a location field on a node.
  sig { params(value: Prism::Location).returns(String) }
  def location(value); end

  sig { returns(String) }
  def output; end

  sig { returns(String) }
  def prefix; end

  # Returns the output as a string.
  sig { returns(String) }
  def to_str; end
end

# Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.
#
#     -> { _1 + _2 }
#     ^^^^^^^^^^^^^^
class Prism::NumberedParametersNode < Prism::Node
  sig { params(maximum: Integer, location: Prism::Location).void }
  def initialize(maximum, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::NumberedParametersNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Integer) }
  def maximum; end
end

# Represents reading a numbered reference to a capture in the previous match.
#
#     $1
#     ^^
class Prism::NumberedReferenceReadNode < Prism::Node
  sig { params(number: Integer, location: Prism::Location).void }
  def initialize(number, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::NumberedReferenceReadNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Integer) }
  def number; end
end

# Represents an optional keyword parameter to a method, block, or lambda definition.
#
#     def a(b: 1)
#           ^^^^
#     end
class Prism::OptionalKeywordParameterNode < Prism::Node
  sig do
    params(
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(flags, name, name_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::OptionalKeywordParameterNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents an optional parameter to a method, block, or lambda definition.
#
#     def a(b = 1)
#           ^^^^^
#     end
class Prism::OptionalParameterNode < Prism::Node
  sig do
    params(
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(flags, name, name_loc, operator_loc, value, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::OptionalParameterNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  sig { returns(Prism::Node) }
  def value; end
end

# Represents the use of the `||` operator or the `or` keyword.
#
#     left or right
#     ^^^^^^^^^^^^^
class Prism::OrNode < Prism::Node
  sig { params(left: Prism::Node, right: Prism::Node, operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(left, right, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::OrNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Prism::Node) }
  def left; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def right; end
end

# Flags for parameter nodes.
module Prism::ParameterFlags
  # a parameter name that has been repeated in the method signature
  REPEATED_PARAMETER = T.let(1 << 0, Integer)
end

# Represents the list of parameters on a method, block, or lambda definition.
#
#     def a(b, c, d)
#           ^^^^^^^
#     end
class Prism::ParametersNode < Prism::Node
  sig do
    params(
      requireds: T::Array[Prism::Node],
      optionals: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      keywords: T::Array[Prism::Node],
      keyword_rest: T.nilable(Prism::Node),
      block: T.nilable(Prism::BlockParameterNode),
      location: Prism::Location
    ).void
  end
  def initialize(requireds, optionals, rest, posts, keywords, keyword_rest, block, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::BlockParameterNode)) }
  def block; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ParametersNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::Node)) }
  def keyword_rest; end

  sig { returns(T::Array[Prism::Node]) }
  def keywords; end

  sig { returns(T::Array[Prism::Node]) }
  def optionals; end

  sig { returns(T::Array[Prism::Node]) }
  def posts; end

  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  sig { returns(T.nilable(Prism::Node)) }
  def rest; end
end

# Represents a parenthesized expression
#
#     (10 + 34)
#     ^^^^^^^^^
class Prism::ParenthesesNode < Prism::Node
  sig do
    params(
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(body, opening_loc, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::ParenthesesNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  def set_newline_flag(newline_marked); end
end

class Prism::ParseError
  sig { returns(Prism::Location) }
  def location; end

  sig { returns(String) }
  def message; end
end

class Prism::ParseResult
  sig { returns(T::Array[Prism::Comment]) }
  def comments; end

  sig { returns(T::Array[Prism::ParseError]) }
  def errors; end

  sig { returns(Prism::Source) }
  def source; end

  sig { returns(Prism::ProgramNode) }
  def value; end

  sig { returns(T::Array[Prism::ParseWarning]) }
  def warnings; end
end

class Prism::ParseWarning
  sig { returns(Prism::Location) }
  def location; end

  sig { returns(String) }
  def message; end
end

# Represents the use of the `^` operator for pinning an expression in a pattern matching expression.
#
#     foo in ^(bar)
#            ^^^^^^
class Prism::PinnedExpressionNode < Prism::Node
  sig do
    params(
      expression: Prism::Node,
      operator_loc: Prism::Location,
      lparen_loc: Prism::Location,
      rparen_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(expression, operator_loc, lparen_loc, rparen_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::PinnedExpressionNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Prism::Node) }
  def expression; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def lparen; end

  sig { returns(Prism::Location) }
  def lparen_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(String) }
  def rparen; end

  sig { returns(Prism::Location) }
  def rparen_loc; end
end

# Represents the use of the `^` operator for pinning a variable in a pattern matching expression.
#
#     foo in ^bar
#            ^^^^
class Prism::PinnedVariableNode < Prism::Node
  sig { params(variable: Prism::Node, operator_loc: Prism::Location, location: Prism::Location).void }
  def initialize(variable, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::PinnedVariableNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(Prism::Node) }
  def variable; end
end

# Represents the use of the `END` keyword.
#
#     END { foo }
#     ^^^^^^^^^^^
class Prism::PostExecutionNode < Prism::Node
  sig do
    params(
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::PostExecutionNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

# Represents the use of the `BEGIN` keyword.
#
#     BEGIN { foo }
#     ^^^^^^^^^^^^^
class Prism::PreExecutionNode < Prism::Node
  sig do
    params(
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::PreExecutionNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

# The top level node of any parse tree.
class Prism::ProgramNode < Prism::Node
  sig { params(locals: T::Array[Symbol], statements: Prism::StatementsNode, location: Prism::Location).void }
  def initialize(locals, statements, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ProgramNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(Prism::StatementsNode) }
  def statements; end
end

# Flags for range and flip-flop nodes.
module Prism::RangeFlags
  # ... operator
  EXCLUDE_END = T.let(1 << 0, Integer)
end

# Represents the use of the `..` or `...` operators.
#
#     1..2
#     ^^^^
#
#     c if a =~ /left/ ... b =~ /right/
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
class Prism::RangeNode < Prism::Node
  sig do
    params(
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(flags, left, right, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::RangeNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def exclude_end?; end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Prism::Node)) }
  def left; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def right; end
end

# Represents a rational number literal.
#
#     1.0r
#     ^^^^
class Prism::RationalNode < Prism::Node
  sig { params(numeric: Prism::Node, location: Prism::Location).void }
  def initialize(numeric, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::RationalNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Prism::Node) }
  def numeric; end
end

# Represents the use of the `redo` keyword.
#
#     redo
#     ^^^^
class Prism::RedoNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::RedoNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Flags for regular expression and match last line nodes.
module Prism::RegularExpressionFlags
  # n - forces the ASCII-8BIT encoding
  ASCII_8BIT = T.let(1 << 5, Integer)

  # e - forces the EUC-JP encoding
  EUC_JP = T.let(1 << 4, Integer)

  # x - ignores whitespace and allows comments in regular expressions
  EXTENDED = T.let(1 << 1, Integer)

  # internal bytes forced the encoding to binary
  FORCED_BINARY_ENCODING = T.let(1 << 9, Integer)

  # internal bytes forced the encoding to US-ASCII
  FORCED_US_ASCII_ENCODING = T.let(1 << 10, Integer)

  # internal bytes forced the encoding to UTF-8
  FORCED_UTF8_ENCODING = T.let(1 << 8, Integer)

  # i - ignores the case of characters when matching
  IGNORE_CASE = T.let(1 << 0, Integer)

  # m - allows $ to match the end of lines within strings
  MULTI_LINE = T.let(1 << 2, Integer)

  # o - only interpolates values into the regular expression once
  ONCE = T.let(1 << 3, Integer)

  # u - forces the UTF-8 encoding
  UTF_8 = T.let(1 << 7, Integer)

  # s - forces the Windows-31J encoding
  WINDOWS_31J = T.let(1 << 6, Integer)
end

# Represents a regular expression literal with no interpolation.
#
#     /foo/i
#     ^^^^^^
class Prism::RegularExpressionNode < Prism::Node
  sig do
    params(
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String,
      location: Prism::Location
    ).void
  end
  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { returns(String) }
  def content; end

  sig { returns(Prism::Location) }
  def content_loc; end

  sig { params(params: T.untyped).returns(Prism::RegularExpressionNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Boolean) }
  def euc_jp?; end

  sig { returns(T::Boolean) }
  def extended?; end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def ignore_case?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Boolean) }
  def multi_line?; end

  sig { returns(T::Boolean) }
  def once?; end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(String) }
  def unescaped; end

  sig { returns(T::Boolean) }
  def utf_8?; end

  sig { returns(T::Boolean) }
  def windows_31j?; end
end

# Represents a required keyword parameter to a method, block, or lambda definition.
#
#     def a(b: )
#           ^^
#     end
class Prism::RequiredKeywordParameterNode < Prism::Node
  sig { params(flags: Integer, name: Symbol, name_loc: Prism::Location, location: Prism::Location).void }
  def initialize(flags, name, name_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::RequiredKeywordParameterNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(Prism::Location) }
  def name_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end
end

# Represents a required parameter to a method, block, or lambda definition.
#
#     def a(b)
#           ^
#     end
class Prism::RequiredParameterNode < Prism::Node
  sig { params(flags: Integer, name: Symbol, location: Prism::Location).void }
  def initialize(flags, name, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::RequiredParameterNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(Symbol) }
  def name; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end
end

# Represents an expression modified with a rescue.
#
#     foo rescue nil
#     ^^^^^^^^^^^^^^
class Prism::RescueModifierNode < Prism::Node
  sig do
    params(
      expression: Prism::Node,
      keyword_loc: Prism::Location,
      rescue_expression: Prism::Node,
      location: Prism::Location
    ).void
  end
  def initialize(expression, keyword_loc, rescue_expression, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::RescueModifierNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Prism::Node) }
  def expression; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(Prism::Node) }
  def rescue_expression; end

  def set_newline_flag(newline_marked); end
end

# Represents a rescue statement.
#
#     begin
#     rescue Foo, *splat, Bar => ex
#       foo
#     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#     end
#
# `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `exception` field.
class Prism::RescueNode < Prism::Node
  sig do
    params(
      keyword_loc: Prism::Location,
      exceptions: T::Array[Prism::Node],
      operator_loc: T.nilable(Prism::Location),
      reference: T.nilable(Prism::Node),
      statements: T.nilable(Prism::StatementsNode),
      consequent: T.nilable(Prism::RescueNode),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, exceptions, operator_loc, reference, statements, consequent, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(Prism::RescueNode)) }
  def consequent; end

  sig { params(params: T.untyped).returns(Prism::RescueNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T::Array[Prism::Node]) }
  def exceptions; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.nilable(String)) }
  def operator; end

  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  sig { returns(T.nilable(Prism::Node)) }
  def reference; end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

# Represents a rest parameter to a method, block, or lambda definition.
#
#     def a(*b)
#           ^^
#     end
class Prism::RestParameterNode < Prism::Node
  sig do
    params(
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(flags, name, name_loc, operator_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::RestParameterNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(Symbol)) }
  def name; end

  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end

  sig { returns(T::Boolean) }
  def repeated_parameter?; end
end

# Represents the use of the `retry` keyword.
#
#     retry
#     ^^^^^
class Prism::RetryNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::RetryNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of the `return` keyword.
#
#     return 1
#     ^^^^^^^^
class Prism::ReturnNode < Prism::Node
  sig do
    params(
      keyword_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, arguments, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::ReturnNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end
end

# Represents the `self` keyword.
#
#     self
#     ^^^^
class Prism::SelfNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::SelfNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents a singleton class declaration involving the `class` keyword.
#
#     class << self end
#     ^^^^^^^^^^^^^^^^^
class Prism::SingletonClassNode < Prism::Node
  sig do
    params(
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      operator_loc: Prism::Location,
      expression: Prism::Node,
      body: T.nilable(Prism::Node),
      end_keyword_loc: Prism::Location,
      location: Prism::Location
    ).void
  end
  def initialize(locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def class_keyword; end

  sig { returns(Prism::Location) }
  def class_keyword_loc; end

  sig { params(params: T.untyped).returns(Prism::SingletonClassNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def end_keyword; end

  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { returns(Prism::Node) }
  def expression; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T::Array[Symbol]) }
  def locals; end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end
end

class Prism::Source
  sig { params(source: String, start_line: Integer, offsets: T::Array[Integer]).void }
  def initialize(source, start_line, offsets); end

  sig { params(value: Integer).returns(Integer) }
  def column(value); end

  sig { params(value: Integer).returns(Integer) }
  def line(value); end

  sig { params(value: Integer).returns(Integer) }
  def line_offset(value); end

  sig { returns(T::Array[Integer]) }
  def offsets; end

  sig { params(offset: Integer, length: Integer).returns(String) }
  def slice(offset, length); end

  sig { returns(String) }
  def source; end
end

# Represents the use of the `__ENCODING__` keyword.
#
#     __ENCODING__
#     ^^^^^^^^^^^^
class Prism::SourceEncodingNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::SourceEncodingNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of the `__FILE__` keyword.
#
#     __FILE__
#     ^^^^^^^^
class Prism::SourceFileNode < Prism::Node
  sig { params(filepath: String, location: Prism::Location).void }
  def initialize(filepath, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::SourceFileNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(String) }
  def filepath; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of the `__LINE__` keyword.
#
#     __LINE__
#     ^^^^^^^^
class Prism::SourceLineNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::SourceLineNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of the splat operator.
#
#     [*a]
#      ^^
class Prism::SplatNode < Prism::Node
  sig { params(operator_loc: Prism::Location, expression: T.nilable(Prism::Node), location: Prism::Location).void }
  def initialize(operator_loc, expression, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::SplatNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(Prism::Node)) }
  def expression; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def operator; end

  sig { returns(Prism::Location) }
  def operator_loc; end
end

# Represents a set of statements contained within some scope.
#
#     foo; bar; baz
#     ^^^^^^^^^^^^^
class Prism::StatementsNode < Prism::Node
  sig { params(body: T::Array[Prism::Node], location: Prism::Location).void }
  def initialize(body, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[Prism::Node]) }
  def body; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::StatementsNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Flags for string nodes.
module Prism::StringFlags
  # internal bytes forced the encoding to binary
  FORCED_BINARY_ENCODING = T.let(1 << 1, Integer)

  # internal bytes forced the encoding to UTF-8
  FORCED_UTF8_ENCODING = T.let(1 << 0, Integer)

  # frozen by virtue of a `frozen_string_literal` comment
  FROZEN = T.let(1 << 2, Integer)
end

# Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.
#
#     "foo"
#     ^^^^^
#
#     %w[foo]
#        ^^^
#
#     "foo #{bar} baz"
#      ^^^^      ^^^^
class Prism::StringNode < Prism::Node
  sig do
    params(
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      content_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      unescaped: String,
      location: Prism::Location
    ).void
  end
  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { returns(String) }
  def content; end

  sig { returns(Prism::Location) }
  def content_loc; end

  sig { params(params: T.untyped).returns(Prism::StringNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def frozen?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(String) }
  def unescaped; end
end

# Represents the use of the `super` keyword with parentheses or arguments.
#
#     super()
#     ^^^^^^^
#
#     super foo, bar
#     ^^^^^^^^^^^^^^
class Prism::SuperNode < Prism::Node
  sig do
    params(
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      block: T.nilable(Prism::Node),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T.nilable(Prism::Node)) }
  def block; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::SuperNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end
end

# Flags for symbol nodes.
module Prism::SymbolFlags
  # internal bytes forced the encoding to binary
  FORCED_BINARY_ENCODING = T.let(1 << 1, Integer)

  # internal bytes forced the encoding to US-ASCII
  FORCED_US_ASCII_ENCODING = T.let(1 << 2, Integer)

  # internal bytes forced the encoding to UTF-8
  FORCED_UTF8_ENCODING = T.let(1 << 0, Integer)
end

# Represents a symbol literal or a symbol contained within a `%i` list.
#
#     :foo
#     ^^^^
#
#     %i[foo]
#        ^^^
class Prism::SymbolNode < Prism::Node
  sig do
    params(
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      value_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      unescaped: String,
      location: Prism::Location
    ).void
  end
  def initialize(flags, opening_loc, value_loc, closing_loc, unescaped, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::SymbolNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(T.nilable(String)) }
  def opening; end

  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  sig { returns(String) }
  def unescaped; end

  sig { returns(T.nilable(String)) }
  def value; end

  sig { returns(T.nilable(Prism::Location)) }
  def value_loc; end
end

class Prism::Token
  sig { params(type: T.untyped, value: String, location: Prism::Location).void }
  def initialize(type, value, location); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { params(keys: T.untyped).returns(T.untyped) }
  def deconstruct_keys(keys); end

  sig { returns(Prism::Location) }
  def location; end

  sig { params(q: T.untyped).returns(T.untyped) }
  def pretty_print(q); end

  sig { returns(T.untyped) }
  def type; end

  sig { returns(String) }
  def value; end
end

# Represents the use of the literal `true` keyword.
#
#     true
#     ^^^^
class Prism::TrueNode < Prism::Node
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::TrueNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end
end

# Represents the use of the `undef` keyword.
#
#     undef :foo, :bar, :baz
#     ^^^^^^^^^^^^^^^^^^^^^^
class Prism::UndefNode < Prism::Node
  sig { params(names: T::Array[Prism::Node], keyword_loc: Prism::Location, location: Prism::Location).void }
  def initialize(names, keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::UndefNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T::Array[Prism::Node]) }
  def names; end
end

# Represents the use of the `unless` keyword, either in the block form or the modifier form.
#
#     bar unless foo
#     ^^^^^^^^^^^^^^
#
#     unless foo then bar end
#     ^^^^^^^^^^^^^^^^^^^^^^^
class Prism::UnlessNode < Prism::Node
  sig do
    params(
      keyword_loc: Prism::Location,
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      consequent: T.nilable(Prism::ElseNode),
      end_keyword_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, predicate, then_keyword_loc, statements, consequent, end_keyword_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(Prism::ElseNode)) }
  def consequent; end

  sig { params(params: T.untyped).returns(Prism::UnlessNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(T.nilable(String)) }
  def end_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(Prism::Node) }
  def predicate; end

  def set_newline_flag(newline_marked); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  sig { returns(T.nilable(String)) }
  def then_keyword; end

  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end
end

# Represents the use of the `until` keyword, either in the block form or the modifier form.
#
#     bar until foo
#     ^^^^^^^^^^^^^
#
#     until foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
class Prism::UntilNode < Prism::Node
  sig do
    params(
      flags: Integer,
      keyword_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      location: Prism::Location
    ).void
  end
  def initialize(flags, keyword_loc, closing_loc, predicate, statements, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def begin_modifier?; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::UntilNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(Prism::Node) }
  def predicate; end

  def set_newline_flag(newline_marked); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

class Prism::Visitor < Prism::BasicVisitor
  # Visit a AliasGlobalVariableNode node
  sig { params(node: Prism::AliasGlobalVariableNode).void }
  def visit_alias_global_variable_node(node); end

  # Visit a AliasMethodNode node
  sig { params(node: Prism::AliasMethodNode).void }
  def visit_alias_method_node(node); end

  # Visit a AlternationPatternNode node
  sig { params(node: Prism::AlternationPatternNode).void }
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node
  sig { params(node: Prism::AndNode).void }
  def visit_and_node(node); end

  # Visit a ArgumentsNode node
  sig { params(node: Prism::ArgumentsNode).void }
  def visit_arguments_node(node); end

  # Visit a ArrayNode node
  sig { params(node: Prism::ArrayNode).void }
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node
  sig { params(node: Prism::ArrayPatternNode).void }
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node
  sig { params(node: Prism::AssocNode).void }
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node
  sig { params(node: Prism::AssocSplatNode).void }
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node
  sig { params(node: Prism::BackReferenceReadNode).void }
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node
  sig { params(node: Prism::BeginNode).void }
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node
  sig { params(node: Prism::BlockArgumentNode).void }
  def visit_block_argument_node(node); end

  # Visit a BlockLocalVariableNode node
  sig { params(node: Prism::BlockLocalVariableNode).void }
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode node
  sig { params(node: Prism::BlockNode).void }
  def visit_block_node(node); end

  # Visit a BlockParameterNode node
  sig { params(node: Prism::BlockParameterNode).void }
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node
  sig { params(node: Prism::BlockParametersNode).void }
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node
  sig { params(node: Prism::BreakNode).void }
  def visit_break_node(node); end

  # Visit a CallAndWriteNode node
  sig { params(node: Prism::CallAndWriteNode).void }
  def visit_call_and_write_node(node); end

  # Visit a CallNode node
  sig { params(node: Prism::CallNode).void }
  def visit_call_node(node); end

  # Visit a CallOperatorWriteNode node
  sig { params(node: Prism::CallOperatorWriteNode).void }
  def visit_call_operator_write_node(node); end

  # Visit a CallOrWriteNode node
  sig { params(node: Prism::CallOrWriteNode).void }
  def visit_call_or_write_node(node); end

  # Visit a CallTargetNode node
  sig { params(node: Prism::CallTargetNode).void }
  def visit_call_target_node(node); end

  # Visit a CapturePatternNode node
  sig { params(node: Prism::CapturePatternNode).void }
  def visit_capture_pattern_node(node); end

  # Visit a CaseMatchNode node
  sig { params(node: Prism::CaseMatchNode).void }
  def visit_case_match_node(node); end

  # Visit a CaseNode node
  sig { params(node: Prism::CaseNode).void }
  def visit_case_node(node); end

  # Visit a ClassNode node
  sig { params(node: Prism::ClassNode).void }
  def visit_class_node(node); end

  # Visit a ClassVariableAndWriteNode node
  sig { params(node: Prism::ClassVariableAndWriteNode).void }
  def visit_class_variable_and_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node
  sig { params(node: Prism::ClassVariableOperatorWriteNode).void }
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableOrWriteNode node
  sig { params(node: Prism::ClassVariableOrWriteNode).void }
  def visit_class_variable_or_write_node(node); end

  # Visit a ClassVariableReadNode node
  sig { params(node: Prism::ClassVariableReadNode).void }
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableTargetNode node
  sig { params(node: Prism::ClassVariableTargetNode).void }
  def visit_class_variable_target_node(node); end

  # Visit a ClassVariableWriteNode node
  sig { params(node: Prism::ClassVariableWriteNode).void }
  def visit_class_variable_write_node(node); end

  # Visit a ConstantAndWriteNode node
  sig { params(node: Prism::ConstantAndWriteNode).void }
  def visit_constant_and_write_node(node); end

  # Visit a ConstantOperatorWriteNode node
  sig { params(node: Prism::ConstantOperatorWriteNode).void }
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantOrWriteNode node
  sig { params(node: Prism::ConstantOrWriteNode).void }
  def visit_constant_or_write_node(node); end

  # Visit a ConstantPathAndWriteNode node
  sig { params(node: Prism::ConstantPathAndWriteNode).void }
  def visit_constant_path_and_write_node(node); end

  # Visit a ConstantPathNode node
  sig { params(node: Prism::ConstantPathNode).void }
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorWriteNode node
  sig { params(node: Prism::ConstantPathOperatorWriteNode).void }
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathOrWriteNode node
  sig { params(node: Prism::ConstantPathOrWriteNode).void }
  def visit_constant_path_or_write_node(node); end

  # Visit a ConstantPathTargetNode node
  sig { params(node: Prism::ConstantPathTargetNode).void }
  def visit_constant_path_target_node(node); end

  # Visit a ConstantPathWriteNode node
  sig { params(node: Prism::ConstantPathWriteNode).void }
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node
  sig { params(node: Prism::ConstantReadNode).void }
  def visit_constant_read_node(node); end

  # Visit a ConstantTargetNode node
  sig { params(node: Prism::ConstantTargetNode).void }
  def visit_constant_target_node(node); end

  # Visit a ConstantWriteNode node
  sig { params(node: Prism::ConstantWriteNode).void }
  def visit_constant_write_node(node); end

  # Visit a DefNode node
  sig { params(node: Prism::DefNode).void }
  def visit_def_node(node); end

  # Visit a DefinedNode node
  sig { params(node: Prism::DefinedNode).void }
  def visit_defined_node(node); end

  # Visit a ElseNode node
  sig { params(node: Prism::ElseNode).void }
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node
  sig { params(node: Prism::EmbeddedStatementsNode).void }
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node
  sig { params(node: Prism::EmbeddedVariableNode).void }
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node
  sig { params(node: Prism::EnsureNode).void }
  def visit_ensure_node(node); end

  # Visit a FalseNode node
  sig { params(node: Prism::FalseNode).void }
  def visit_false_node(node); end

  # Visit a FindPatternNode node
  sig { params(node: Prism::FindPatternNode).void }
  def visit_find_pattern_node(node); end

  # Visit a FlipFlopNode node
  sig { params(node: Prism::FlipFlopNode).void }
  def visit_flip_flop_node(node); end

  # Visit a FloatNode node
  sig { params(node: Prism::FloatNode).void }
  def visit_float_node(node); end

  # Visit a ForNode node
  sig { params(node: Prism::ForNode).void }
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node
  sig { params(node: Prism::ForwardingArgumentsNode).void }
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node
  sig { params(node: Prism::ForwardingParameterNode).void }
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node
  sig { params(node: Prism::ForwardingSuperNode).void }
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableAndWriteNode node
  sig { params(node: Prism::GlobalVariableAndWriteNode).void }
  def visit_global_variable_and_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node
  sig { params(node: Prism::GlobalVariableOperatorWriteNode).void }
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableOrWriteNode node
  sig { params(node: Prism::GlobalVariableOrWriteNode).void }
  def visit_global_variable_or_write_node(node); end

  # Visit a GlobalVariableReadNode node
  sig { params(node: Prism::GlobalVariableReadNode).void }
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableTargetNode node
  sig { params(node: Prism::GlobalVariableTargetNode).void }
  def visit_global_variable_target_node(node); end

  # Visit a GlobalVariableWriteNode node
  sig { params(node: Prism::GlobalVariableWriteNode).void }
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node
  sig { params(node: Prism::HashNode).void }
  def visit_hash_node(node); end

  # Visit a HashPatternNode node
  sig { params(node: Prism::HashPatternNode).void }
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node
  sig { params(node: Prism::IfNode).void }
  def visit_if_node(node); end

  # Visit a ImaginaryNode node
  sig { params(node: Prism::ImaginaryNode).void }
  def visit_imaginary_node(node); end

  # Visit a ImplicitNode node
  sig { params(node: Prism::ImplicitNode).void }
  def visit_implicit_node(node); end

  # Visit a ImplicitRestNode node
  sig { params(node: Prism::ImplicitRestNode).void }
  def visit_implicit_rest_node(node); end

  # Visit a InNode node
  sig { params(node: Prism::InNode).void }
  def visit_in_node(node); end

  # Visit a IndexAndWriteNode node
  sig { params(node: Prism::IndexAndWriteNode).void }
  def visit_index_and_write_node(node); end

  # Visit a IndexOperatorWriteNode node
  sig { params(node: Prism::IndexOperatorWriteNode).void }
  def visit_index_operator_write_node(node); end

  # Visit a IndexOrWriteNode node
  sig { params(node: Prism::IndexOrWriteNode).void }
  def visit_index_or_write_node(node); end

  # Visit a IndexTargetNode node
  sig { params(node: Prism::IndexTargetNode).void }
  def visit_index_target_node(node); end

  # Visit a InstanceVariableAndWriteNode node
  sig { params(node: Prism::InstanceVariableAndWriteNode).void }
  def visit_instance_variable_and_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node
  sig { params(node: Prism::InstanceVariableOperatorWriteNode).void }
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableOrWriteNode node
  sig { params(node: Prism::InstanceVariableOrWriteNode).void }
  def visit_instance_variable_or_write_node(node); end

  # Visit a InstanceVariableReadNode node
  sig { params(node: Prism::InstanceVariableReadNode).void }
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableTargetNode node
  sig { params(node: Prism::InstanceVariableTargetNode).void }
  def visit_instance_variable_target_node(node); end

  # Visit a InstanceVariableWriteNode node
  sig { params(node: Prism::InstanceVariableWriteNode).void }
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node
  sig { params(node: Prism::IntegerNode).void }
  def visit_integer_node(node); end

  # Visit a InterpolatedMatchLastLineNode node
  sig { params(node: Prism::InterpolatedMatchLastLineNode).void }
  def visit_interpolated_match_last_line_node(node); end

  # Visit a InterpolatedRegularExpressionNode node
  sig { params(node: Prism::InterpolatedRegularExpressionNode).void }
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node
  sig { params(node: Prism::InterpolatedStringNode).void }
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node
  sig { params(node: Prism::InterpolatedSymbolNode).void }
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node
  sig { params(node: Prism::InterpolatedXStringNode).void }
  def visit_interpolated_x_string_node(node); end

  # Visit a KeywordHashNode node
  sig { params(node: Prism::KeywordHashNode).void }
  def visit_keyword_hash_node(node); end

  # Visit a KeywordRestParameterNode node
  sig { params(node: Prism::KeywordRestParameterNode).void }
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node
  sig { params(node: Prism::LambdaNode).void }
  def visit_lambda_node(node); end

  # Visit a LocalVariableAndWriteNode node
  sig { params(node: Prism::LocalVariableAndWriteNode).void }
  def visit_local_variable_and_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node
  sig { params(node: Prism::LocalVariableOperatorWriteNode).void }
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode node
  sig { params(node: Prism::LocalVariableOrWriteNode).void }
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode node
  sig { params(node: Prism::LocalVariableReadNode).void }
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableTargetNode node
  sig { params(node: Prism::LocalVariableTargetNode).void }
  def visit_local_variable_target_node(node); end

  # Visit a LocalVariableWriteNode node
  sig { params(node: Prism::LocalVariableWriteNode).void }
  def visit_local_variable_write_node(node); end

  # Visit a MatchLastLineNode node
  sig { params(node: Prism::MatchLastLineNode).void }
  def visit_match_last_line_node(node); end

  # Visit a MatchPredicateNode node
  sig { params(node: Prism::MatchPredicateNode).void }
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node
  sig { params(node: Prism::MatchRequiredNode).void }
  def visit_match_required_node(node); end

  # Visit a MatchWriteNode node
  sig { params(node: Prism::MatchWriteNode).void }
  def visit_match_write_node(node); end

  # Visit a MissingNode node
  sig { params(node: Prism::MissingNode).void }
  def visit_missing_node(node); end

  # Visit a ModuleNode node
  sig { params(node: Prism::ModuleNode).void }
  def visit_module_node(node); end

  # Visit a MultiTargetNode node
  sig { params(node: Prism::MultiTargetNode).void }
  def visit_multi_target_node(node); end

  # Visit a MultiWriteNode node
  sig { params(node: Prism::MultiWriteNode).void }
  def visit_multi_write_node(node); end

  # Visit a NextNode node
  sig { params(node: Prism::NextNode).void }
  def visit_next_node(node); end

  # Visit a NilNode node
  sig { params(node: Prism::NilNode).void }
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node
  sig { params(node: Prism::NoKeywordsParameterNode).void }
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedParametersNode node
  sig { params(node: Prism::NumberedParametersNode).void }
  def visit_numbered_parameters_node(node); end

  # Visit a NumberedReferenceReadNode node
  sig { params(node: Prism::NumberedReferenceReadNode).void }
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalKeywordParameterNode node
  sig { params(node: Prism::OptionalKeywordParameterNode).void }
  def visit_optional_keyword_parameter_node(node); end

  # Visit a OptionalParameterNode node
  sig { params(node: Prism::OptionalParameterNode).void }
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node
  sig { params(node: Prism::OrNode).void }
  def visit_or_node(node); end

  # Visit a ParametersNode node
  sig { params(node: Prism::ParametersNode).void }
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node
  sig { params(node: Prism::ParenthesesNode).void }
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node
  sig { params(node: Prism::PinnedExpressionNode).void }
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node
  sig { params(node: Prism::PinnedVariableNode).void }
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node
  sig { params(node: Prism::PostExecutionNode).void }
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node
  sig { params(node: Prism::PreExecutionNode).void }
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node
  sig { params(node: Prism::ProgramNode).void }
  def visit_program_node(node); end

  # Visit a RangeNode node
  sig { params(node: Prism::RangeNode).void }
  def visit_range_node(node); end

  # Visit a RationalNode node
  sig { params(node: Prism::RationalNode).void }
  def visit_rational_node(node); end

  # Visit a RedoNode node
  sig { params(node: Prism::RedoNode).void }
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node
  sig { params(node: Prism::RegularExpressionNode).void }
  def visit_regular_expression_node(node); end

  # Visit a RequiredKeywordParameterNode node
  sig { params(node: Prism::RequiredKeywordParameterNode).void }
  def visit_required_keyword_parameter_node(node); end

  # Visit a RequiredParameterNode node
  sig { params(node: Prism::RequiredParameterNode).void }
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node
  sig { params(node: Prism::RescueModifierNode).void }
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node
  sig { params(node: Prism::RescueNode).void }
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node
  sig { params(node: Prism::RestParameterNode).void }
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node
  sig { params(node: Prism::RetryNode).void }
  def visit_retry_node(node); end

  # Visit a ReturnNode node
  sig { params(node: Prism::ReturnNode).void }
  def visit_return_node(node); end

  # Visit a SelfNode node
  sig { params(node: Prism::SelfNode).void }
  def visit_self_node(node); end

  # Visit a SingletonClassNode node
  sig { params(node: Prism::SingletonClassNode).void }
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node
  sig { params(node: Prism::SourceEncodingNode).void }
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node
  sig { params(node: Prism::SourceFileNode).void }
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node
  sig { params(node: Prism::SourceLineNode).void }
  def visit_source_line_node(node); end

  # Visit a SplatNode node
  sig { params(node: Prism::SplatNode).void }
  def visit_splat_node(node); end

  # Visit a StatementsNode node
  sig { params(node: Prism::StatementsNode).void }
  def visit_statements_node(node); end

  # Visit a StringNode node
  sig { params(node: Prism::StringNode).void }
  def visit_string_node(node); end

  # Visit a SuperNode node
  sig { params(node: Prism::SuperNode).void }
  def visit_super_node(node); end

  # Visit a SymbolNode node
  sig { params(node: Prism::SymbolNode).void }
  def visit_symbol_node(node); end

  # Visit a TrueNode node
  sig { params(node: Prism::TrueNode).void }
  def visit_true_node(node); end

  # Visit a UndefNode node
  sig { params(node: Prism::UndefNode).void }
  def visit_undef_node(node); end

  # Visit a UnlessNode node
  sig { params(node: Prism::UnlessNode).void }
  def visit_unless_node(node); end

  # Visit a UntilNode node
  sig { params(node: Prism::UntilNode).void }
  def visit_until_node(node); end

  # Visit a WhenNode node
  sig { params(node: Prism::WhenNode).void }
  def visit_when_node(node); end

  # Visit a WhileNode node
  sig { params(node: Prism::WhileNode).void }
  def visit_while_node(node); end

  # Visit a XStringNode node
  sig { params(node: Prism::XStringNode).void }
  def visit_x_string_node(node); end

  # Visit a YieldNode node
  sig { params(node: Prism::YieldNode).void }
  def visit_yield_node(node); end
end

# Represents the use of the `when` keyword within a case statement.
#
#     case true
#     when true
#     ^^^^^^^^^
#     end
class Prism::WhenNode < Prism::Node
  sig do
    params(
      keyword_loc: Prism::Location,
      conditions: T::Array[Prism::Node],
      statements: T.nilable(Prism::StatementsNode),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, conditions, statements, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  sig { params(params: T.untyped).returns(Prism::WhenNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

# Represents the use of the `while` keyword, either in the block form or the modifier form.
#
#     bar while foo
#     ^^^^^^^^^^^^^
#
#     while foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
class Prism::WhileNode < Prism::Node
  sig do
    params(
      flags: Integer,
      keyword_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      location: Prism::Location
    ).void
  end
  def initialize(flags, keyword_loc, closing_loc, predicate, statements, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Boolean) }
  def begin_modifier?; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(T.nilable(String)) }
  def closing; end

  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  sig { params(params: T.untyped).returns(Prism::WhileNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(Prism::Node) }
  def predicate; end

  def set_newline_flag(newline_marked); end

  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end
end

# Represents an xstring literal with no interpolation.
#
#     `foo`
#     ^^^^^
class Prism::XStringNode < Prism::Node
  sig do
    params(
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String,
      location: Prism::Location
    ).void
  end
  def initialize(flags, opening_loc, content_loc, closing_loc, unescaped, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { returns(String) }
  def closing; end

  sig { returns(Prism::Location) }
  def closing_loc; end

  sig { returns(String) }
  def content; end

  sig { returns(Prism::Location) }
  def content_loc; end

  sig { params(params: T.untyped).returns(Prism::XStringNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { returns(Integer) }
  def flags; end

  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def opening; end

  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(String) }
  def unescaped; end
end

# Represents the use of the `yield` keyword.
#
#     yield 1
#     ^^^^^^^
class Prism::YieldNode < Prism::Node
  sig do
    params(
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      location: Prism::Location
    ).void
  end
  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, location); end

  sig { params(visitor: Prism::Visitor).void }
  def accept(visitor); end

  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  sig { params(params: T.untyped).returns(Prism::YieldNode) }
  def copy(**params); end

  sig { returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  sig do
    params(
      keys: T::Array[Symbol]
    ).returns(T::Hash[Symbol, T.nilable(T.any(Prism::Node, T::Array[Prism::Node], String, Prism::Token, T::Array[Prism::Token], Prism::Location))])
  end
  def deconstruct_keys(keys); end

  sig { params(inspector: Prism::NodeInspector).returns(String) }
  def inspect(inspector); end

  sig { returns(String) }
  def keyword; end

  sig { returns(Prism::Location) }
  def keyword_loc; end

  sig { returns(T.nilable(String)) }
  def lparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  sig { returns(T.nilable(String)) }
  def rparen; end

  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end
end
